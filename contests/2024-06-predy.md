# Predy Finance

[Unlock seamless](https://code4rena.com/audits/2024-05-predy), gas-free trading with fully on-chain, vault-free Intent-based DEX for Perpetuals and Gamma, with no virtual positions.

## Audit Findings Summary

| ID | Title | Severity |
|----|----------|----------|
| [M-1](#m-1-multiple-instances-of-usage-of-slot0-to-calculate-square-root-price-which-is-easily-manipulatable) | Multiple instances of usage of `slot0` to calculate square root price, which is easily manipulatable | Medium |
| [M-2](#m-2-malicious-user-can-create-positions-that-can-never-be-liquidated-breaking-protocol-invariant) | Malicious user can create positions that can never be liquidated, breaking protocol invariant | Medium |
---

## [M-1] Multiple instances of usage of `slot0` to calculate square root price, which is easily manipulatable

# Vulnerability details

## Impact
There are multiple instances where `Uniswap's slot0` is used to calculate the `square root price`.

This is dangerous as `slot0` returns the poolâ€™s spot price, which can be manipulated by buying and selling assets within the pool using flash loans, since this price is given by the current ratio of reserves in the pool.

An attacker can make the spot price favorable for them to acheive their desired outcome.

## Proof of Concept
As mentioned, `slot0` is used to fetch the spot price in multiple instances throughout the protocol:

[Perp.sol#L206](https://github.com/code-423n4/2024-05-predy/blob/main/src/libraries/Perp.sol#L206)
```javascript
(uint160 currentSqrtPrice, int24 currentTick,,,,,) = IUniswapV3Pool(_sqrtAssetStatus.uniswapPool).slot0();
```

[UniHelper.sol#L13-L15)](https://github.com/code-423n4/2024-05-predy/blob/main/src/libraries/UniHelper.sol#L13-L15)
```javascript
function getSqrtPrice(address uniswapPoolAddress) internal view returns (uint160 sqrtPrice) {
    (sqrtPrice,,,,,,) = IUniswapV3Pool(uniswapPoolAddress).slot0();
}
```

An example of where this is used is when trades are executed:

[Trade.sol#L49](https://github.com/code-423n4/2024-05-predy/blob/main/src/libraries/Trade.sol#L49)
```javascript
tradeResult.sqrtPrice = getSqrtPrice(pairStatus.sqrtAssetStatus.uniswapPool, pairStatus.isQuoteZero);
```

An attacker can manipulate the spot price via flash loans to make trades favorable for them.

## Tools Used
Manual Review

## Recommended Mitigation Steps
Use the TWAP instead of slot0 when obtaining the price

```diff
function setLockDuration(uint256 _duration) external notPaused {
    if (_duration > configStorage.getUint(StorageKey.MaxLockDuration))
        revert MaximumLockDurationError();

    playerSettings[msg.sender].lockDuration = uint32(_duration);
    // update any existing lock
    uint256 configuredTokensLength = configuredTokenContracts.length;
    for (uint256 i; i < configuredTokensLength; i++) {
        address tokenContract = configuredTokenContracts[i];
        if (lockedTokens[msg.sender][tokenContract].quantity > 0) {
            // check they are not setting lock time before current unlocktime
            if (
                uint32(block.timestamp) + uint32(_duration) <
                lockedTokens[msg.sender][tokenContract].unlockTime
            ) {
                revert LockDurationReducedError();
            }

-               uint32 lastLockTime = lockedTokens[msg.sender][tokenContract]
-                   .lastLockTime;
-               lockedTokens[msg.sender][tokenContract].unlockTime =
-                   lastLockTime +
-                   uint32(_duration);

+               lockedTokens[msg.sender][tokenContract].unlockTime += _duration;

        }
    }

    emit LockDuration(msg.sender, _duration);
}
```

## [M-2] Malicious user can create positions that can never be liquidated, breaking protocol invariant


# Vulnerability details

## Impact
The protocol mentions the following in the contest [README](https://code4rena.com/audits/2024-05-predy#top:~:text=Assuming%20sufficient%20liquidity%2C%20safe%20vaults%20cannot%20be%20liquidated%2C%20whereas%20unsafe%20vaults%20can%20be%20liquidated.%20This%20ensures%20that%20only%20positions%20that%20pose%20a%20risk%20to%20the%20system%20are%20targeted%20for%20liquidation%2C%20maintaining%20the%20integrity%20of%20the%20platform.) as one of the main invariants: `"Assuming sufficient liquidity, safe vaults cannot be liquidated, whereas unsafe vaults can be liquidated. This ensures that only positions that pose a risk to the system are targeted for liquidation, maintaining the integrity of the platform.".`

When liquidating an unsafe vault (position), it is removed from the list of the user's positions. The index of the position is searched by looping through all of the user's positions. Once the index is found, the position is removed from the list.

A malicious user can create enough positions that looping through the list of their positions will cause DoS due to insufficient gas.

Since their unsafe positions can never be liquidated, this invariant will be broken.

## Proof of Concept
Any user can liquidate a bad position in either `Gamma` or `Perp` markets.

[GammaTradeMarket.sol#L143-L144](https://github.com/code-423n4/2024-05-predy/blob/main/src/markets/gamma/GammaTradeMarket.sol#L143-L144)
```javascript
   tradeResult =
       _predyPool.execLiquidationCall(vaultId, closeRatio, _getSettlementDataFromV3(settlementParams, msg.sender));
```

When liquidating a position, a trade is executed to settle the position.

[LiquidationLogic.sol#L67](https://github.com/code-423n4/2024-05-predy/blob/main/src/libraries/logic/LiquidationLogic.sol#L67)
```javascript
tradeResult = Trade.trade(globalData, tradeParams, settlementData);
```

During the trade callback, the position is removed

[GammaTradeMarket.sol#L99](https://github.com/code-423n4/2024-05-predy/blob/main/src/markets/gamma/GammaTradeMarket.sol#L99)
```javascript
_removePosition(tradeParams.vaultId);
```

When the position is removed, `removeItem` is called with the entire list of the trader's positions `positionIDs[trader]` (who is being liquidated on behalf of the caller)

[GammaTradeMarket.sol#L402-L406)](https://github.com/code-423n4/2024-05-predy/blob/main/src/markets/gamma/GammaTradeMarket.sol#L402-L406)
```javascript
positionIDs[trader].removeItem(positionId);
```

[ArrayLib.sol#L9-L31](https://github.com/code-423n4/2024-05-predy/blob/main/src/markets/gamma/ArrayLib.sol#L9-L31)
```javascript
   function removeItem(uint256[] storage items, uint256 item) internal {
@>      uint256 index = getItemIndex(items, item);

       removeItemByIndex(items, index);
   }

   function removeItemByIndex(uint256[] storage items, uint256 index) internal {
       items[index] = items[items.length - 1];
       items.pop();
   }

   function getItemIndex(uint256[] memory items, uint256 item) internal pure returns (uint256) {
       uint256 index = type(uint256).max;

@>      for (uint256 i = 0; i < items.length; i++) {
           if (items[i] == item) {
               index = i;
               break;
           }
       }

       return index;
   }
```
We can see the flow of the call is `removeItem()` => `getItemIndex()`

Here we loop through the entire list of all of the trader's positions until the correct position is found.

A malicious user can create enough positions so that this loop will run out of gas and cause DoS.

Any bad positions that they have will not have the ability to be liquidated.

## Tools Used
Manual Review.

## Recommended Mitigation Steps
Rather than looping through all of the user's positions, consider creating a mapping between the position and index of the position when it is created. The index can then be retrieved in constant time.
