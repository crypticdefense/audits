# Pike Finance and Tapio Protocol

[Pike Market Protocol](https://cantina.xyz/code/a0806644-7d91-457a-a08d-aee2db73f352/overview) Pike Market is a decentralized lending and borrowing protocol built for EVMs, designed to provide a secure, scalable, and flexible environment for users to manage their digital assets. It allows users to supply assets to earn yield or borrow against collateralized assets through the pToken contracts.

[Tapio Protocol](https://cantina.xyz/code/a0806644-7d91-457a-a08d-aee2db73f352/overview) Tapio is an asset protocol that enables the creation of Self-Pegging Assets (SPAs) through advanced StableSwap AMM. Tapio features sophisticated governance mechanisms, dynamic fee structures, and built-in risk management systems, all accessible through a suite of interconnected smart contracts designed for seamless integration.

## Audit Findings Summary

| ID | Title | Severity |
|----|----------|----------|
| [M-1](#m-1-_synctotalsupply-uses-stale-balances-to-update-total-supply) | _syncTotalSupply() uses stale balances to update total supply | Medium |
| [M-2](#m-2-spatokenaddbuffer-does-not-take-into-account-buffer-bad-debt) | SPAToken::addBuffer does not take into account buffer bad debt | Medium |
| [M-3](#m-3-selfpeggingasset-dynamic-fee-uses-incorrect-balances-by-double-applying-exchange-rate-in-mintredeem) | SelfPeggingAsset dynamic fee uses incorrect balances by double applying exchange rate in mint/redeem | Medium |
| [M-4](#m-4-ptokenmodule-deposit-and-withdraw-calls-should-have-slippage-protection) | PTokenModule deposit and withdraw calls should have slippage protection | Medium |
| [M-5](#m-5-user-can-dos-liquidations-by-repaying-dust-amount) | User can DoS liquidations by repaying dust amount | Medium |
| [M-6](#m-6-partial-liquidation-can-seize-all-collateral-and-leave-bad-debt) | Partial liquidation can seize all collateral and leave bad debt | Medium |
| [L-1](#l-1-incorrect-rounding-direction-upon-burning-shares-allows-users-to-redeem-free-tokens) | Incorrect rounding direction upon burning shares allows users to redeem free tokens | Low |
| [L-2](#l-2-ptokens-contract-breaks-eip-4626-compliance-in-multiple-cases) | pTokens contract breaks EIP-4626 compliance in multiple cases | Low |
| [L-3](#l-3-user-can-gas-grief-liquidations-via-entermarkets) | User can gas grief liquidations via enterMarkets() | Low |
| [I-1](#i-1-front-running-with-1-wei-ptoken-transfer-prevents-collateral-entry-and-allows-borrower-to-remain-liquidatable) | Front-running with 1 wei pToken transfer prevents collateral entry and allows borrower to remain liquidatable | Informational |
---

## [M-1] _syncTotalSupply() uses stale balances to update total supply

## Summary

The following modifier is used in mint/redeem/swap calls to ensure total supply is and A is up to date:

https://cantina.xyz/code/a0806644-7d91-457a-a08d-aee2db73f352/tapio-eth/src/SelfPeggingAsset.sol?lines=373,373
```javascript
modifier syncRamping() {
        if (address(rampAController) != address(0)) {
            uint256 currentA = getCurrentA();
            if (currentA != A) {
                A = currentA;
                _syncTotalSupply();
            }
        }
        _;
    }
function _syncTotalSupply() internal {
@>      uint256 newD = _getD(balances, A);

        if (totalSupply > newD) {
            // A decreased
            poolToken.removeTotalSupply(totalSupply - newD, true, false);
            totalSupply = newD;
        } else if (newD > totalSupply) {
            // A increased
            poolToken.addBuffer(newD - totalSupply);
            totalSupply = newD;
        }
    }
```
When _getD(balances, A); is called to get the new totalSupply, it inputs an outdated balances parameter.

This is unlike the collectFeeOrYield call for example, which ensures balances is up to date prior to changing the supply:
```javascript
function collectFeeOrYield(bool isFee) internal returns (uint256) {
        uint256 oldD = totalSupply;

        uint256 newD;
@>      (balances, newD) = getUpdatedBalancesAndD();
        totalSupply = newD;

        if (oldD > newD) {
            uint256 delta = oldD - newD;
            uint256 margin = isFee ? feeErrorMargin : yieldErrorMargin;

            if (delta < margin) return 0;

            // Cover losses using the buffer
            poolToken.removeTotalSupply(delta, true, true);
            return 0;
        }

        uint256 feeAmount = newD - oldD;
        if (feeAmount == 0) return 0;

        poolToken.addTotalSupply(feeAmount);
        if (isFee) emit FeeCollected(feeAmount, totalSupply);
        else emit YieldCollected(feeAmount, totalSupply);
        return feeAmount;
    }
```
This call updates the balances before calling _getD.

Not only can balances change via donations, etc, but it can change because of the exchangeRate. So _syncTotalSupply is using both an outdated balances list and an outdated exchange rate when updating the totalSupply (because the cached balances list reflects the old exchange rate).

This means the subsequent operations within _syncTotalSupply will be either removing an incorrect totalSupply amount from the SPAToken contract or adding an incorrect amount into the buffer. This would cause users and LPs to suffer as their rewards/tokens will not reflect the true amount they should receive.

## Recommendation

Simply ensure balances are updated by utilizing getUpdatedBalancesAndD() instead of _getD() (newD will then reflect the updated balances and latest exchange rate):
```diff
function _syncTotalSupply() internal {
+   (balances, uint256 newD) = getUpdatedBalancesAndD();
    if (totalSupply > newD) {
        // A decreased
        poolToken.removeTotalSupply(totalSupply - newD, true, false);
    } else if (newD > totalSupply) {
        // A increased
        poolToken.addBuffer(newD - totalSupply);
    }
    totalSupply = newD;
}
```

## [M-2] SPAToken::addBuffer does not take into account buffer bad debt

## Summary

In certain cases throughout the SelfPeggingAsset pool (i.e rebase()), it specifies to remove total supply with withDebt = true on the LP token contract:

https://cantina.xyz/code/a0806644-7d91-457a-a08d-aee2db73f352/tapio-eth/src/SPAToken.sol?lines=387,387
```javascript
function removeTotalSupply(uint256 _amount, bool isBuffer, bool withDebt) external {
        require(msg.sender == pool, NoPool());
        require(_amount != 0, InvalidAmount());

        if (isBuffer) {
            require(_amount <= bufferAmount, InsufficientBuffer());
            bufferAmount -= _amount;
@>          if (withDebt) {
                bufferBadDebt += _amount;
            }
            emit BufferDecreased(_amount, bufferAmount);
        } else {
            require(_amount <= totalSupply, InsufficientSupply());
            totalSupply -= _amount;
            emit NegativelyRebased(_amount, totalSupply);
        }
    }
```
This means that any new supply will prioritize re-filling the buffer until bad debt is removed:
```javascript
function addTotalSupply(uint256 _amount) external {
        require(msg.sender == pool, NoPool());
        require(_amount != 0, InvalidAmount());

 @>     if (bufferBadDebt >= _amount) {
            bufferBadDebt -= _amount;
            bufferAmount += _amount;
            emit BufferIncreased(_amount, bufferAmount);
 @>         return;
        }

        uint256 prevAmount = _amount;
        uint256 prevBufferBadDebt = bufferBadDebt;
        _amount = _amount - bufferBadDebt;
        bufferAmount += bufferBadDebt;
        bufferBadDebt = 0;

        uint256 _deltaBuffer = (bufferPercent * _amount) / BUFFER_DENOMINATOR;
        uint256 actualAmount = _amount - _deltaBuffer;

        totalSupply += actualAmount;
        totalRewards += actualAmount;
        bufferAmount += _deltaBuffer;

        emit BufferIncreased(_deltaBuffer + prevBufferBadDebt, bufferAmount);
        emit RewardsMinted(prevAmount, actualAmount);
    }
```
Until bad debt is removed from the buffer, totalSupply is not updated with the new supply added. However, throughout the SelfPeggingAsset pool, the buffer is increased directly. For example in syncTotalSupply which is called in every mint,redeem, swap call (also applies to donations):
```javascript
function _syncTotalSupply() internal {
        uint256 newD = _getD(balances, A);

        if (totalSupply > newD) {
            // A decreased
            poolToken.removeTotalSupply(totalSupply - newD, true, false);
            totalSupply = newD;
        } else if (newD > totalSupply) {
            // A increased
@>          poolToken.addBuffer(newD - totalSupply);
            totalSupply = newD;
        }
    }
```
But this increases the buffer without taking into account the buffer bad debt:

https://cantina.xyz/code/a0806644-7d91-457a-a08d-aee2db73f352/tapio-eth/src/SPAToken.sol?lines=409,409
```javascript
function addBuffer(uint256 _amount) external {
        require(msg.sender == pool, NoPool());
        require(_amount != 0, InvalidAmount());

        bufferAmount += _amount;
        emit BufferIncreased(_amount, bufferAmount);
    }
```
This means that despite buffer bad debt being removed, the bufferBadDebt accounting is not updated, so any addTotalSupply will still treat the buffer as if it has bad debt and continue to delay updating the actual totalSupply.

The impact is that totalSupply remains a lower value than in reality, which means it will decrease LP rewards causing a loss for them.

In other words, that amount that went to the buffer will now be double counted and not go to totalSupply.

## Recommendation

Take into account the buffer bad debt in addBuffer().

## [M-3] SelfPeggingAsset dynamic fee uses incorrect balances by double applying exchange rate in mint/redeem

## Summary

Looking at the mint call of the pool:

https://cantina.xyz/code/a0806644-7d91-457a-a08d-aee2db73f352/tapio-eth/src/SelfPeggingAsset.sol?lines=478,478
```javascript
function mint(
        uint256[] calldata _amounts,
        uint256 _minMintAmount
    )
        external
        nonReentrant
        syncRamping
        returns (uint256)
    {
        require(!paused, Paused());
        require(balances.length == _amounts.length, InvalidAmount());

        for (uint256 i = 0; i < _amounts.length; i++) {
            _updateMultiplierForToken(i);
        }

        collectFeeOrYield(false);
        uint256[] memory _balances = balances;
        uint256 oldD = totalSupply;
        bool hasNonZero = false;
        for (uint256 i = 0; i < _balances.length; i++) {
            if (_amounts[i] < INITIAL_MINT_MIN) require(oldD > 0, ZeroAmount());
            if (_amounts[i] != 0) hasNonZero = true;
        }
        require(hasNonZero, ZeroAmount());

@>      _balances = _updateBalancesForDeposit(_balances, _amounts);
        uint256 newD = _getD(_balances, A);
        // newD should be bigger than or equal to oldD
        uint256 mintAmount = newD - oldD;

        uint256 feeAmount = 0;
        if (mintFee > 0 && oldD != 0) {
            uint256 ys = (newD + oldD) / _balances.length;
            uint256[] memory fees = new uint256[](_balances.length);
            for (uint256 i = 0; i < _balances.length; i++) {
                uint256 idealBalance = newD * balances[i] / oldD;
                uint256 difference =
                    idealBalance > _balances[i] ? idealBalance - _balances[i] : _balances[i] - idealBalance;
@>              uint256 xs = ((balances[i] + _balances[i]) * exchangeRateProviders[i].exchangeRate())
                    / (10 ** exchangeRateDecimals[i]);
                fees[i] = (difference * (_dynamicFee(xs, ys, mintFee) + _volatilityFee(i, mintFee))) / FEE_DENOMINATOR;
                _balances[i] -= fees[i];
            }

            newD = _getD(_balances, A);
            mintAmount = newD - oldD;
        }

        if (mintAmount < _minMintAmount) revert InsufficientMintAmount(mintAmount, _minMintAmount);

        // Transfer tokens into the swap
        for (uint256 i = 0; i < _amounts.length; i++) {
            if (_amounts[i] == 0) continue;
            // Update the balance in storage
            balances[i] = _balances[i];
            IERC20(tokens[i]).safeTransferFrom(msg.sender, address(this), _amounts[i]);
        }
        totalSupply = oldD + mintAmount;
        poolToken.mintShares(msg.sender, mintAmount);
        feeAmount = collectFeeOrYield(true);
        lastActivity = block.timestamp;
        emit Minted(msg.sender, mintAmount, _amounts, feeAmount);
        return mintAmount;
    }
```
In this pool, balances are already stored after normalizing by applying exchange rates and precision:
```javascript
function _updateBalancesForDeposit(
        uint256[] memory _balances,
        uint256[] calldata _amounts
    )
        internal
        view
        returns (uint256[] memory)
    {
        for (uint256 i = 0; i < _balances.length; i++) {
            if (_amounts[i] == 0) continue;
            uint256 bal = (_amounts[i] * exchangeRateProviders[i].exchangeRate()) / (10 ** exchangeRateDecimals[i]);
@>          _balances[i] += bal * precisions[i];
        }
        return _balances;
    }
```
This applies to both balances[i] and _balances[i]. But the normalization again is applied when calculating xs:
```javascript
uint256 xs = ((balances[i] + _balances[i]) * exchangeRateProviders[i].exchangeRate())
                    / (10 ** exchangeRateDecimals[i]);
```
This will lead to an incorrect fee calculation, depending on the exchange rate it can either undercharge users (causing loss for lp/protocol) or overcharge them (causing loss to users).

## Recommendation

Do not re-apply the exchange rate when calculating xs

## [M-4] PTokenModule deposit and withdraw calls should have slippage protection

## Summary

Both deposit and withdraw calls use the following exchange rate to determine how many shares to mint and assets to return to the user:

https://cantina.xyz/code/a0806644-7d91-457a-a08d-aee2db73f352/pike-local-markets/src/pike-market/modules/pToken/PTokenModule.sol?lines=1554,1554
```javascript
function exchangeRateStoredInternal() internal view returns (uint256) {
        uint256 _totalSupply = _getPTokenStorage().totalSupply;
        if (_totalSupply == 0) {
            /*
             * If there are no tokens minted:
             *  exchangeRate = initialExchangeRate
             */
            return _getPTokenStorage().initialExchangeRateMantissa;
        } else {
            /*
             * Otherwise:
             *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply
             */
@>          uint256 cashPlusBorrowsMinusReserves = getCash()
                + _getPTokenStorage().totalBorrows - _getPTokenStorage().totalReserves;
            return
                cashPlusBorrowsMinusReserves * ExponentialNoError.expScale / _totalSupply;
        }
    }
```
- getCash() => total balance of token within the contract.

- _getPTokenStorage().totalBorrows => total amount of token borrowed

- _getPTokenStorage().totalReserves => total protocol reserves

The issue is that these values can change disproportionally before function execution:

Interest accrual / repayments / new borrows → change totalBorrows and cash

Reserve operations (_addReservesFresh, _reduceReserves*) → change totalReserves. Note that both owner and config roles have separate dedicated shares they can claim individually, which reduces totalReserves. Interest accrual also changes the reserve value

Other users’ deposits/withdraws → change cash and totalSupply

Therefore, a user's deposit call can lead to fewer pTokens minted and withdrawal call can lead to fewer assets returned than expected due to exchange rate changes before function execution.

## Recommendation

Add slippage protection parameters to the following functions:

- deposit: add minimum shares to receive

- mint: add maximum assets to transfer

- withdraw: add maximum shares to redeem

- redeem: add minimum assets to receive

Also consider applying it to liquidations.

## [M-5] User can DoS liquidations by repaying dust amount

## Summary

A liquidator can repay a small portion of the borrower's debt, seize all collateral (due to 8% bonus) and leave the protocol with bad debt.

## Finding Description

The following is executed during liquidations:

https://cantina.xyz/code/a0806644-7d91-457a-a08d-aee2db73f352/pike-local-markets/src/pike-market/modules/riskEngine/RiskEngineModule.sol?lines=866,866
```javascript
function liquidateCalculateSeizeTokens(
        address borrower,
        address pTokenBorrowed,
        address pTokenCollateral,
        uint256 actualRepayAmount
    ) external view returns (RiskEngineError.Error, uint256) {
        address oracleEngine = _getRiskEngineStorage().oracle;

        /* Read oracle prices for borrowed and collateral markets */
        uint256 priceBorrowedMantissa =
            IOracleEngine(oracleEngine).getUnderlyingPrice(IPToken(pTokenBorrowed));
        uint256 priceCollateralMantissa =
            IOracleEngine(oracleEngine).getUnderlyingPrice(IPToken(pTokenCollateral));
        if (priceBorrowedMantissa == 0 || priceCollateralMantissa == 0) {
            return (RiskEngineError.Error.PRICE_ERROR, 0);
        }

        /*
         * Get the exchange rate and calculate the number of collateral tokens to seize:
         *  seizeAmount = actualRepayAmount * liquidationIncentive * priceBorrowed / priceCollateral
         *  seizeTokens = seizeAmount / exchangeRate
         *   = actualRepayAmount * (liquidationIncentive * priceBorrowed) / (priceCollateral * exchangeRate)
         */
        uint8 emodeCategory = _getRiskEngineStorage().accountCategory[borrower];
        uint256 exchangeRateMantissa = IPToken(pTokenCollateral).exchangeRateStored(); // Note: reverts on error
        uint256 seizeTokens;
        uint256 liquidationIncentiveMantissa;
        ExponentialNoError.Exp numerator;
        ExponentialNoError.Exp denominator;
        ExponentialNoError.Exp ratio;

@>      if (emodeCategory == 0) {
            liquidationIncentiveMantissa = _getRiskEngineStorage().markets[pTokenCollateral]
                .baseConfiguration
                .liquidationIncentiveMantissa;
        } else {
            liquidationIncentiveMantissa = _getRiskEngineStorage().emodes[emodeCategory]
                .baseConfiguration
                .liquidationIncentiveMantissa;
        }
        numerator =
            liquidationIncentiveMantissa.toExp().mul_(priceBorrowedMantissa.toExp());

        denominator = priceCollateralMantissa.toExp().mul_(exchangeRateMantissa.toExp());

        ratio = numerator.div_(denominator);

        seizeTokens = ratio.mul_ScalarTruncate(actualRepayAmount);

        return (RiskEngineError.Error.NO_ERROR, seizeTokens);
    }
```
Depending on the eMode of the user configured, the liquidationIncentive (bonus) is adjusted. eModeCategory == 0 (default value) has a bonus configured to 8% from the test files.

Given that liquidators always receive this bonus, this creates the following issue (numbers used for simplicity):

Assume closeFactor of 50% (meaning user must repay <= closeFactor * borrowBalance) as configured in tests and 8% liquidation bonus

Borrower has 100 tokenA collateral (worth 1000 USD) and 100 tokenB borrowed (worth 2500 USD), so borrower is clearly liquidatable

Liquidator specifies 37.037037 tokenB to repay

https://cantina.xyz/code/a0806644-7d91-457a-a08d-aee2db73f352/pike-local-markets/src/pike-market/modules/riskEngine/RiskEngineModule.sol?lines=639,639
```javascript
function liquidateBorrowAllowed(
        address pTokenBorrowed,
        address pTokenCollateral,
        address borrower,
        uint256 repayAmount
    ) external view returns (RiskEngineError.Error) {
        RiskEngineData storage $ = _getRiskEngineStorage();

        if (!$.markets[pTokenBorrowed].isListed || !$.markets[pTokenCollateral].isListed)
        {
            return RiskEngineError.Error.MARKET_NOT_LISTED;
        }

        uint256 borrowBalance = IPToken(pTokenBorrowed).borrowBalanceStored(borrower);

        /* allow accounts to be liquidated if the market is deprecated */
        if (isDeprecated(IPToken(pTokenBorrowed))) {
            require(borrowBalance >= repayAmount, RiskEngineError.RepayMoreThanBorrowed());
        } else {
            /* The borrower must have shortfall in order to be liquidatable */
            (RiskEngineError.Error err,, uint256 shortfall) =
                getAccountLiquidityInternal(borrower);
            if (err != RiskEngineError.Error.NO_ERROR) {
                return err;
            }

            if (shortfall == 0) {
                return RiskEngineError.Error.INSUFFICIENT_SHORTFALL;
            }

            /* The liquidator may not repay more than what is allowed by the closeFactor */
@>          uint256 maxClose = $.closeFactorMantissa[pTokenBorrowed].toExp()
                .mul_ScalarTruncate(borrowBalance);
@>          if (repayAmount > maxClose) {
                return RiskEngineError.Error.TOO_MUCH_REPAY;
            }
        }
        return RiskEngineError.Error.NO_ERROR;
    }
```
maxClose = 50 tokenB (50% closeFactor), so the check will pass because 37.037037 tokenB repayAmount < 50 tokenB.

liquidateCalculateSeizeTokens is executed and calculates seizeTokens = 37.037037 x 2.7 = 100 tokenA
Note that the 2.7 value is calcuated by seizeTokens = repayB x (liquidationIncentive x priceB)/(priceA x exchangeRateA) => priceB = 25 USD/token, priceA=10 USD/token, exchangeRate = 1 (for simplicity), bonus = 1.08 (8%)

Liquidator repays ~37 tokenB (~925 USD) and receives 100 tokenA collateral (1,000 USD), which equates to about 74 USD profit due to bonus. Now 0 collateral and ~63 borrowed tokens remain.

Borrower debt remains ~63 borrowed tokenB (~1,574 USD). Since there is no borrower collateral left, this remaining 1,574 USD amount remains as bad debt with 0 collateral backing.

The point here is that liquidators are still incentivized to liquidate positions with bad debt to take all collateral for a profit (due to 8% bonus), leaving bad debt and loss for the protocol.

## Recommendation

If bad debt remains, consider removing the bonus

## [M-6] Partial liquidation can seize all collateral and leave bad debt

## Summary

A liquidator can repay a small portion of the borrower's debt, seize all collateral (due to 8% bonus) and leave the protocol with bad debt.

## Finding Description

The following is executed during liquidations:

https://cantina.xyz/code/a0806644-7d91-457a-a08d-aee2db73f352/pike-local-markets/src/pike-market/modules/riskEngine/RiskEngineModule.sol?lines=866,866
```javascript
function liquidateCalculateSeizeTokens(
        address borrower,
        address pTokenBorrowed,
        address pTokenCollateral,
        uint256 actualRepayAmount
    ) external view returns (RiskEngineError.Error, uint256) {
        address oracleEngine = _getRiskEngineStorage().oracle;

        /* Read oracle prices for borrowed and collateral markets */
        uint256 priceBorrowedMantissa =
            IOracleEngine(oracleEngine).getUnderlyingPrice(IPToken(pTokenBorrowed));
        uint256 priceCollateralMantissa =
            IOracleEngine(oracleEngine).getUnderlyingPrice(IPToken(pTokenCollateral));
        if (priceBorrowedMantissa == 0 || priceCollateralMantissa == 0) {
            return (RiskEngineError.Error.PRICE_ERROR, 0);
        }

        /*
         * Get the exchange rate and calculate the number of collateral tokens to seize:
         *  seizeAmount = actualRepayAmount * liquidationIncentive * priceBorrowed / priceCollateral
         *  seizeTokens = seizeAmount / exchangeRate
         *   = actualRepayAmount * (liquidationIncentive * priceBorrowed) / (priceCollateral * exchangeRate)
         */
        uint8 emodeCategory = _getRiskEngineStorage().accountCategory[borrower];
        uint256 exchangeRateMantissa = IPToken(pTokenCollateral).exchangeRateStored(); // Note: reverts on error
        uint256 seizeTokens;
        uint256 liquidationIncentiveMantissa;
        ExponentialNoError.Exp numerator;
        ExponentialNoError.Exp denominator;
        ExponentialNoError.Exp ratio;

@>      if (emodeCategory == 0) {
            liquidationIncentiveMantissa = _getRiskEngineStorage().markets[pTokenCollateral]
                .baseConfiguration
                .liquidationIncentiveMantissa;
        } else {
            liquidationIncentiveMantissa = _getRiskEngineStorage().emodes[emodeCategory]
                .baseConfiguration
                .liquidationIncentiveMantissa;
        }
        numerator =
            liquidationIncentiveMantissa.toExp().mul_(priceBorrowedMantissa.toExp());

        denominator = priceCollateralMantissa.toExp().mul_(exchangeRateMantissa.toExp());

        ratio = numerator.div_(denominator);

        seizeTokens = ratio.mul_ScalarTruncate(actualRepayAmount);

        return (RiskEngineError.Error.NO_ERROR, seizeTokens);
    }
```
Depending on the eMode of the user configured, the liquidationIncentive (bonus) is adjusted. eModeCategory == 0 (default value) has a bonus configured to 8% from the test files.

Given that liquidators always receive this bonus, this creates the following issue (numbers used for simplicity):

Assume closeFactor of 50% (meaning user must repay <= closeFactor * borrowBalance) as configured in tests and 8% liquidation bonus

Borrower has 100 tokenA collateral (worth 1000 USD) and 100 tokenB borrowed (worth 2500 USD), so borrower is clearly liquidatable

Liquidator specifies 37.037037 tokenB to repay

https://cantina.xyz/code/a0806644-7d91-457a-a08d-aee2db73f352/pike-local-markets/src/pike-market/modules/riskEngine/RiskEngineModule.sol?lines=639,639
```javascript
function liquidateBorrowAllowed(
        address pTokenBorrowed,
        address pTokenCollateral,
        address borrower,
        uint256 repayAmount
    ) external view returns (RiskEngineError.Error) {
        RiskEngineData storage $ = _getRiskEngineStorage();

        if (!$.markets[pTokenBorrowed].isListed || !$.markets[pTokenCollateral].isListed)
        {
            return RiskEngineError.Error.MARKET_NOT_LISTED;
        }

        uint256 borrowBalance = IPToken(pTokenBorrowed).borrowBalanceStored(borrower);

        /* allow accounts to be liquidated if the market is deprecated */
        if (isDeprecated(IPToken(pTokenBorrowed))) {
            require(borrowBalance >= repayAmount, RiskEngineError.RepayMoreThanBorrowed());
        } else {
            /* The borrower must have shortfall in order to be liquidatable */
            (RiskEngineError.Error err,, uint256 shortfall) =
                getAccountLiquidityInternal(borrower);
            if (err != RiskEngineError.Error.NO_ERROR) {
                return err;
            }

            if (shortfall == 0) {
                return RiskEngineError.Error.INSUFFICIENT_SHORTFALL;
            }

            /* The liquidator may not repay more than what is allowed by the closeFactor */
@>          uint256 maxClose = $.closeFactorMantissa[pTokenBorrowed].toExp()
                .mul_ScalarTruncate(borrowBalance);
@>          if (repayAmount > maxClose) {
                return RiskEngineError.Error.TOO_MUCH_REPAY;
            }
        }
        return RiskEngineError.Error.NO_ERROR;
    }
```
maxClose = 50 tokenB (50% closeFactor), so the check will pass because 37.037037 tokenB repayAmount < 50 tokenB.

liquidateCalculateSeizeTokens is executed and calculates seizeTokens = 37.037037 x 2.7 = 100 tokenA
Note that the 2.7 value is calcuated by seizeTokens = repayB x (liquidationIncentive x priceB)/(priceA x exchangeRateA) => priceB = 25 USD/token, priceA=10 USD/token, exchangeRate = 1 (for simplicity), bonus = 1.08 (8%)

Liquidator repays ~37 tokenB (~925 USD) and receives 100 tokenA collateral (1,000 USD), which equates to about 74 USD profit due to bonus. Now 0 collateral and ~63 borrowed tokens remain.

Borrower debt remains ~63 borrowed tokenB (~1,574 USD). Since there is no borrower collateral left, this remaining 1,574 USD amount remains as bad debt with 0 collateral backing.

The point here is that liquidators are still incentivized to liquidate positions with bad debt to take all collateral for a profit (due to 8% bonus), leaving bad debt and loss for the protocol.

## Recommendation

If bad debt remains, consider removing the bonus

## [L-1] Incorrect rounding direction upon burning shares allows users to redeem free tokens

## Summary

In the SelfPeggingAsset pool, users can redeem their tokens for underlying:
```javascript
function redeemSingle(
        uint256 _amount,
        uint256 _i,
        uint256 _minRedeemAmount
    )
        external
        nonReentrant
        syncRamping
        returns (uint256)
    {
        require(!paused, Paused());
        require(_amount > 0, ZeroAmount());
        require(_i < balances.length, InvalidToken());

        _updateMultiplierForToken(_i);

        collectFeeOrYield(false);
        uint256[] memory _balances = balances;
        uint256 oldD = totalSupply;
        uint256 oldBalanceI = _balances[_i];

        uint256 newD = oldD - _amount;
        // y is converted(18 decimals)
        uint256 y = _getY(_balances, _i, newD, A);
        // dy is not converted
        // dy = (balance[i] - y - 1) / precisions[i] in case there was rounding errors
        uint256 dy = (_balances[_i] - y - 1) / precisions[_i];
        uint256 feeAmount = 0;
        if (redeemFee > 0) {
            uint256 xs =
                ((oldBalanceI + y) * exchangeRateProviders[_i].exchangeRate()) / (10 ** exchangeRateDecimals[_i]) / 2;
            uint256 ys = (oldD + newD) / (_balances.length * 2);
            uint256 dynamicFee = _dynamicFee(xs, ys, redeemFee);
            feeAmount = (dy * (dynamicFee + _volatilityFee(_i, redeemFee))) / FEE_DENOMINATOR;
            dy -= feeAmount;
        }
        _minRedeemAmount =
            (_minRedeemAmount * exchangeRateProviders[_i].exchangeRate()) / (10 ** exchangeRateDecimals[_i]);
        if (dy < _minRedeemAmount) revert InsufficientRedeemAmount(dy, _minRedeemAmount);

        // Updates token balance in storage
        balances[_i] = y;
        uint256 transferAmount = (dy * (10 ** exchangeRateDecimals[_i])) / exchangeRateProviders[_i].exchangeRate();
        uint256[] memory amounts = new uint256[](_balances.length);
        amounts[_i] = transferAmount;
@>      IERC20(tokens[_i]).safeTransfer(msg.sender, transferAmount);
        totalSupply = newD;
@>      poolToken.burnSharesFrom(msg.sender, _amount);
        feeAmount = collectFeeOrYield(true);
        lastActivity = block.timestamp;
        emit Redeemed(msg.sender, _amount, amounts, feeAmount);
        return transferAmount;
    }
```
poolToken.burnSharesFrom is executed with the amount specified:

https://cantina.xyz/code/a0806644-7d91-457a-a08d-aee2db73f352/tapio-eth/src/SPAToken.sol?lines=588,588
```javascript
/**
     * @notice Destroys `_sharesAmount` shares from `_account`'s holdings, decreasing the total amount of shares.
     */
    function _burnShares(address _account, uint256 _tokenAmount) internal returns (uint256 newTotalShares) {
        require(_account != address(0), BurnFromZeroAddr());

        uint256 _balance = getPeggedTokenByShares(_sharesOf(_account));
        if (_tokenAmount > _balance) {
            revert InsufficientBalance(_balance, _tokenAmount);
        }

@>      uint256 _sharesAmount = getSharesByPeggedToken(_tokenAmount);
@>      shares[_account] -= _sharesAmount;
        totalShares -= _sharesAmount;
        newTotalShares = totalShares;
        totalSupply -= _tokenAmount;

        _emitTransferAfterBurningShares(_account, _sharesAmount);
    }
```

The shares to burn are calculated via getSharesByPeggedToken which rounds down in favour of the user and against the protocol:

```javascript
function getSharesByPeggedToken(uint256 _spaTokenAmount) public view returns (uint256) {
        if (totalSupply == 0) {
            return 0;
        } else {
            return (_spaTokenAmount * totalShares) / totalSupply;
        }
    }
```
This means that if a user specifies an amount such that (_spaTokenAmount * totalShares) < totalSupply, 0 shares will be burned in return for underlying, effectively stealing from the pool, causing loss of funds for innocent users.

## Recommendation

Round up against the user when calculating shares to burn

## [L-2] pTokens contract breaks EIP-4626 compliance in multiple cases

## Summary

Pike Finance docs mention that the pTokens contract follows the ERC-4626 vault standard.

However, it breaks the standard in the following 3 cases:

1. Both maxDeposit and maxMint calls.

Looking at the EIP-4626 docs for maxDeposit and maxMint:

"MUST factor in both global and user-specific limits, like if deposits are entirely disabled (even temporarily) it MUST return 0." ... "MUST NOT revert."

So it must not revert and must return 0 instead.

However, looking at maxDeposit:

PTokenModule https://cantina.xyz/code/a0806644-7d91-457a-a08d-aee2db73f352/pike-local-markets/src/pike-market/modules/pToken/PTokenModule.sol?lines=761,761
```javascript
function maxDeposit(address account) public view returns (uint256) {
        RiskEngineError.Error allowed =
@>          _getPTokenStorage().riskEngine.mintAllowed(account, address(this), 1);
        if (allowed != RiskEngineError.Error.NO_ERROR) {
            return 0;
        }
        uint256 cap = _getPTokenStorage().riskEngine.supplyCap(address(this));
        if (cap != type(uint256).max) {
            return cap - totalAssets();
        }
        return cap;
    }
```
mintAllowed actually reverts if minting is paused:
```javascript
function mintAllowed(address account, address pToken, uint256 mintAmount)
        external
        view
        returns (RiskEngineError.Error)
    {
        RiskEngineData storage $ = _getRiskEngineStorage();

        // Pausing is a very serious situation - we revert to sound the alarms
@>      require(!$.mintGuardianPaused[pToken], RiskEngineError.MintPaused());

        if (!$.markets[pToken].isListed) {
            return RiskEngineError.Error.MARKET_NOT_LISTED;
        }

        uint8 category = $.accountCategory[account];
        // Should check if account is in emode and pToken is allowed
        if (category != 0 && !$.emodes[category].allowed) {
            return RiskEngineError.Error.EMODE_NOT_ALLOWED;
        }

        uint256 cap = $.supplyCaps[pToken];
        // Skipping the cap check for uncapped coins to save some gas
        if (cap != type(uint256).max) {
            uint256 pTokenSupply = IPToken(pToken).totalSupply();

            uint256 nextTotalSupply = IPToken(pToken).exchangeRateStored().toExp()
                .mul_ScalarTruncateAddUInt(pTokenSupply, mintAmount);
            if (nextTotalSupply > cap) {
                return RiskEngineError.Error.SUPPLY_CAP_EXCEEDED;
            }
        }

        return RiskEngineError.Error.NO_ERROR;
    }
```
The same applies to maxMint().

2. maxWithdraw()

Looking at the EIP-4626 docs for maxWithdraw:

"MUST NOT revert.".

Looking at the implementation:

https://cantina.xyz/code/a0806644-7d91-457a-a08d-aee2db73f352/pike-local-markets/src/pike-market/modules/riskEngine/RiskEngineModule.sol?lines=733,733
```javascript
function maxWithdraw(address pToken, address account)
        external
        view
        returns (uint256)
    {
        RiskEngineData storage $ = _getRiskEngineStorage();

        if (!$.markets[pToken].isListed) {
            return 0;
        }

        uint256 underlyingBalance = IPToken(pToken).balanceOfUnderlying(account);

        // Get the normalized price of the asset
@>      uint256 oraclePriceMantissa =
            IOracleEngine($.oracle).getUnderlyingPrice(IPToken(pToken));

        ExponentialNoError.Exp oraclePrice = oraclePriceMantissa.toExp();

        (RiskEngineError.Error err, uint256 withdrawLiquidity) =
@>          getWithdrawLiquidityInternal(account, _getCollateralFactor);
        if (err != RiskEngineError.Error.NO_ERROR) {
            return 0;
        }

        if (
            !$.markets[pToken].collateralMembership[account]
                || underlyingBalance.mul_(oraclePrice) < withdrawLiquidity
        ) {
            return underlyingBalance;
        } else {
            return withdrawLiquidity.div_(oraclePrice);
        }
    }
```
However, the oracle engine implementation of Pike Finance actually reverts if the oracle fails

That applies to both the IOracleEngine($.oracle).getUnderlyingPrice(IPToken(pToken)) and the getWithdrawLiquidityInternal() calls which fetch these oracle prices.

Therefore, by reverting in this case, the EIP compliance is broken.

3. previewDeposit and previewMint:

Looking at the EIP-4626 docs for previewDeposit and previewMint:

"MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called in the same transaction."

During deposit, the first depositer gets less shares minted, due to dead shares implementation that prevents inflation attacks:

https://cantina.xyz/code/a0806644-7d91-457a-a08d-aee2db73f352/pike-local-markets/src/pike-market/modules/pToken/PTokenModule.sol?lines=856,856
```javascript
/// mint dead shares if it's initial mint
        if ($.totalSupply == 0) {
            $.totalSupply = mintTokens;
            mintTokens = mintTokens - MINIMUM_DEAD_SHARES;
        } else {
            $.totalSupply = $.totalSupply + mintTokens;
        }
```
The true tokens that are minted to the first depositer is mintTokens = mintTokens - MINIMUM_DEAD_SHARES, however previewDeposit/previewMint don't reflect that and instead return amount without the dead shares applied. This breaks compliance that "MUST return as close to" the amount of shares that should be received.

All cases clearly break compliance with ERC4626, thus the pTokens contract isn't correctly following the ERC-4626 vault standard as stated, causing issues and unexpected DoS with external integrators for example who trust that the contract is ERC4626 compliant as stated.

## Recommendation

1. When minting is paused, consider returning error instead of reverting (i.e return RiskEngineError.MintPaused()).

2. Wrap try/catch around oracle and return 0 in the catch block within maxWithdraw()

3. If totalSupply == 0 take into account the minimum dead shares in previewDeposit and previewMint calls

## [L-3] User can gas grief liquidations via enterMarkets()

## Summary

During liquidations, the following loop is executed:

https://cantina.xyz/code/a0806644-7d91-457a-a08d-aee2db73f352/pike-local-markets/src/pike-market/modules/riskEngine/RiskEngineModule.sol?lines=1235,1235
```javascript
function getHypotheticalAccountLiquidityInternal(
        address account,
        IPToken pTokenModify,
        uint8 categoryId,
        uint256 redeemTokens,
        uint256 borrowAmount,
        function (IPToken,uint8) internal view returns (ExponentialNoError.Exp) threshold
    ) internal view returns (RiskEngineError.Error, uint256, uint256) {
        AccountLiquidityLocalVars memory vars; // Holds all our calculation results
        vars.oracle = IOracleEngine(_getRiskEngineStorage().oracle);

        // For each asset the account is in
@>      IPToken[] memory accountAssets = _getRiskEngineStorage().accountAssets[account];
@>      for (uint256 i = 0; i < accountAssets.length; i++) {
            IPToken asset = accountAssets[i];

            // Read the balances and exchange rate from the pToken
            (vars.pTokenBalance, vars.borrowBalance, vars.exchangeRateMantissa) =
                asset.getAccountSnapshot(account);

            // Get the normalized price of the asset
            vars.oraclePriceMantissa = vars.oracle.getUnderlyingPrice(asset);
            if (vars.oraclePriceMantissa == 0) {
                return (RiskEngineError.Error.PRICE_ERROR, 0, 0);
            }

            vars.oraclePrice = vars.oraclePriceMantissa.toExp();

            vars.threshold = threshold(asset, categoryId);
            vars.exchangeRate = vars.exchangeRateMantissa.toExp();

            // Pre-compute a conversion factor from tokens -> ether (normalized price value)
            vars.tokensToDenom =
                vars.oraclePrice.mul_(vars.threshold.mul_(vars.exchangeRate));

            if (
                _getRiskEngineStorage().markets[address(asset)].collateralMembership[account]
            ) {
                // sumCollateral += tokensToDenom * pTokenBalance
                vars.sumCollateral = vars.tokensToDenom.mul_ScalarTruncateAddUInt(
                    vars.pTokenBalance, vars.sumCollateral
                );
            }
            // sumBorrowPlusEffects += oraclePrice * borrowBalance
            vars.sumBorrowPlusEffects = vars.oraclePrice.mul_ScalarTruncateAddUInt(
                vars.borrowBalance, vars.sumBorrowPlusEffects
            );
            // Calculate effects of interacting with pTokenModify
            if (asset == pTokenModify) {
                // redeem effect
                // sumBorrowPlusEffects += tokensToDenom * redeemTokens
                vars.sumBorrowPlusEffects = vars.tokensToDenom.mul_ScalarTruncateAddUInt(
                    redeemTokens, vars.sumBorrowPlusEffects
                );

                // borrow effect
                // sumBorrowPlusEffects += oraclePrice * borrowAmount
                vars.sumBorrowPlusEffects = vars.oraclePrice.mul_ScalarTruncateAddUInt(
                    borrowAmount, vars.sumBorrowPlusEffects
                );
            }
        }

        // These are safe, as the underflow condition is checked first
        if (vars.sumCollateral > vars.sumBorrowPlusEffects) {
            return (
                RiskEngineError.Error.NO_ERROR,
                vars.sumCollateral - vars.sumBorrowPlusEffects,
                0
            );
        } else {
            return (
                RiskEngineError.Error.NO_ERROR,
                0,
                vars.sumBorrowPlusEffects - vars.sumCollateral
            );
        }
    }
```
Each asset the user holds is looped through.

A user can take advantage of this by registering themselves in every existing market through enterMarkets():

https://cantina.xyz/code/a0806644-7d91-457a-a08d-aee2db73f352/pike-local-markets/src/pike-market/modules/riskEngine/RiskEngineModule.sol?lines=373,373
```javascript
function enterMarkets(address[] memory pTokens) external returns (uint256[] memory) {
        uint256 len = pTokens.length;

        uint256[] memory results = new uint256[](len);
        for (uint256 i = 0; i < len; i++) {
            IPToken pToken = IPToken(pTokens[i]);

@>          results[i] = uint256(addToMarketCollateralInternal(pToken, msg.sender));
        }

        return results;
    }
```
The addToMarketCollateralInternal call proceeds to execute $.accountAssets[supplier].push(pToken);. This increases the list of assets to loop through.

A user can register to every single existing market to then DoS liquidations due to insufficient gas, leading to bad debt and loss of funds for the protocol. (Even if the entire list doesn't DoS, it can become far more computationally expensive, increasing gas costs and reducing liquidation incentives).

## Recommendation

Enforce a maxAssets cap to ensure users cannot just register for all possible assets causing gas griefing/DoS.

## [I-1] Front-running with 1 wei pToken transfer prevents collateral entry and allows borrower to remain liquidatable

## Summary

Assume a user has tokenA collateral 10,000 USD, and tokenB borrowed now worth 11,000 USD.

Since the user is liquidatable, they attempt to prevent liquidation by adding tokenC worth $5,000.

This will increase their totalCollateral so there will no longer be any shortfall:

https://cantina.xyz/code/a0806644-7d91-457a-a08d-aee2db73f352/pike-local-markets/src/pike-market/modules/riskEngine/RiskEngineModule.sol?lines=1235,1235
```javascript
function getHypotheticalAccountLiquidityInternal(
        address account,
        IPToken pTokenModify,
        uint8 categoryId,
        uint256 redeemTokens,
        uint256 borrowAmount,
        function (IPToken,uint8) internal view returns (ExponentialNoError.Exp) threshold
    ) internal view returns (RiskEngineError.Error, uint256, uint256) {
        AccountLiquidityLocalVars memory vars; // Holds all our calculation results
        vars.oracle = IOracleEngine(_getRiskEngineStorage().oracle);

        // For each asset the account is in
@>      IPToken[] memory accountAssets = _getRiskEngineStorage().accountAssets[account];
        for (uint256 i = 0; i < accountAssets.length; i++) {
            IPToken asset = accountAssets[i];

            // Read the balances and exchange rate from the pToken
            (vars.pTokenBalance, vars.borrowBalance, vars.exchangeRateMantissa) =
                asset.getAccountSnapshot(account);

            // Get the normalized price of the asset
            vars.oraclePriceMantissa = vars.oracle.getUnderlyingPrice(asset);
            if (vars.oraclePriceMantissa == 0) {
                return (RiskEngineError.Error.PRICE_ERROR, 0, 0);
            }

            vars.oraclePrice = vars.oraclePriceMantissa.toExp();

            vars.threshold = threshold(asset, categoryId);
            vars.exchangeRate = vars.exchangeRateMantissa.toExp();

            // Pre-compute a conversion factor from tokens -> ether (normalized price value)
            vars.tokensToDenom =
                vars.oraclePrice.mul_(vars.threshold.mul_(vars.exchangeRate));

            if (
@>              _getRiskEngineStorage().markets[address(asset)].collateralMembership[account]
            ) {
                // sumCollateral += tokensToDenom * pTokenBalance
@>              vars.sumCollateral = vars.tokensToDenom.mul_ScalarTruncateAddUInt(
                    vars.pTokenBalance, vars.sumCollateral
                );
            }
            // sumBorrowPlusEffects += oraclePrice * borrowBalance
            vars.sumBorrowPlusEffects = vars.oraclePrice.mul_ScalarTruncateAddUInt(
                vars.borrowBalance, vars.sumBorrowPlusEffects
            );
            // Calculate effects of interacting with pTokenModify
            if (asset == pTokenModify) {
                // redeem effect
                // sumBorrowPlusEffects += tokensToDenom * redeemTokens
                vars.sumBorrowPlusEffects = vars.tokensToDenom.mul_ScalarTruncateAddUInt(
                    redeemTokens, vars.sumBorrowPlusEffects
                );

                // borrow effect
                // sumBorrowPlusEffects += oraclePrice * borrowAmount
                vars.sumBorrowPlusEffects = vars.oraclePrice.mul_ScalarTruncateAddUInt(
                    borrowAmount, vars.sumBorrowPlusEffects
                );
            }
        }

        // These are safe, as the underflow condition is checked first
@>      if (vars.sumCollateral > vars.sumBorrowPlusEffects) {
            return (
                RiskEngineError.Error.NO_ERROR,
                vars.sumCollateral - vars.sumBorrowPlusEffects,
                0
            );
        } else {
            return (
                RiskEngineError.Error.NO_ERROR,
                0,
                vars.sumBorrowPlusEffects - vars.sumCollateral
            );
        }
    }
```
However, their deposit of tokenC collateral can be front-ran with a 1 wei transfer, preventing tokenC to be added to the borrower's accountAssets list:

https://cantina.xyz/code/a0806644-7d91-457a-a08d-aee2db73f352/pike-local-markets/src/pike-market/modules/pToken/PTokenModule.sol?lines=804,804
```javascript
function mintFresh(
        address minter,
        address onBehalfOf,
        uint256 mintTokensIn,
        uint256 mintAmountIn
    ) internal returns (uint256, uint256) {
        require(mintTokensIn == 0 || mintAmountIn == 0, PTokenError.OnlyOneInputAllowed());

        ExponentialNoError.Exp exchangeRate = exchangeRateStoredInternal().toExp();

        if (mintTokensIn > 0) {
            /* mintAmount = mintTokensIn x exchangeRateStored */
            mintAmountIn = mintTokensIn.mul_(exchangeRate);
        }

        PTokenData storage $ = _getPTokenStorage();

        /* Fail if mint not allowed */
        RiskEngineError.Error allowed =
            $.riskEngine.mintAllowed(minter, address(this), mintAmountIn);
        require(
            allowed == RiskEngineError.Error.NO_ERROR,
            PTokenError.MintRiskEngineRejection(uint256(allowed))
        );

        /* Verify market's block timestamp equals current block timestamp */
        require(
            $.accrualBlockTimestamp == _getBlockTimestamp(),
            PTokenError.MintFreshnessCheck()
        );

        /////////////////////////
        // EFFECTS & INTERACTIONS
        // (No safe failures beyond this point)

        /*
         *  We call `doTransferIn` for the minter and the mintAmount.
         *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if
         *  side-effects occurred. The function returns the amount actually transferred,
         *  in case of a fee. On success, the pToken holds an additional `actualMintAmount`
         *  of cash.
         */
        uint256 actualMintAmount = doTransferIn(minter, mintAmountIn);

        /*
         * We get the current exchange rate and calculate the number of pTokens to be minted:
         *  mintTokens = actualMintAmount / exchangeRate
         */

        uint256 mintTokens = actualMintAmount.div_(exchangeRate);

        /// mint dead shares if it's initial mint
        if ($.totalSupply == 0) {
            $.totalSupply = mintTokens;
            mintTokens = mintTokens - MINIMUM_DEAD_SHARES;
        } else {
            $.totalSupply = $.totalSupply + mintTokens;
        }

        require(mintTokens != 0, PTokenError.ZeroTokensMinted());

@>      if ($.accountTokens[onBehalfOf] == 0) {
@>          $.riskEngine.mintVerify(onBehalfOf);
        }

        /*
         * We calculate the new total supply of pTokens and onBehalfOf token balance, checking for overflow:
         *  totalSupplyNew = totalSupply + mintTokens
         *  accountTokensNew = accountTokens[onBehalfOf] + mintTokens
         * And write them into storage
         */
        $.accountTokens[onBehalfOf] = $.accountTokens[onBehalfOf] + mintTokens;

        /* We emit a Mint event, and a Transfer event */
        emit Deposit(minter, onBehalfOf, actualMintAmount, mintTokens);
        emit Transfer(address(0), onBehalfOf, mintTokens);
        return (mintTokens, actualMintAmount);
    }
```
The riskEngine::mintVerify call adds the token to the collateral list, but skips it if the accountTokens is > 0.

A malicious user can front-run and transfer 1 wei of tokenC collateral to the borrower by initiating the PTokenModule::transfer call. This will skip the mintVerify call when the borrower deposits tokenC (because now accountTokens > 0) and the tokenC won't be added to their list of assets.

Now, despite having enough collateral deposited to prevent liquidation, the borrower remains liquidatable.

It's important to note that once the borrower realizes this, they can call RiskEngineModule::enterMarkets() to officially have their collateral tokenC added to the list. But that is only if they notice, and they can still be liquidated before that time.

## Recommendation

I recommend removing the accountTokens == 0 check, not much gas is saved anyways as the function returns early if the token is already added as collateral.
```diff
-      if ($.accountTokens[onBehalfOf] == 0) {
          $.riskEngine.mintVerify(onBehalfOf);
-        }
```
