# TITLES Publishing Protocol

[TITLES](https://audits.sherlock.xyz/contests/326) builds creative tools powered by artist-owned AI models. The underlying TITLES protocol enables the publishing of referential NFTs, including managing attribution and splitting payments with the creators of the attributed works.

## Audit Findings Summary

| ID | Title | Severity |
|----|----------|----------|
| [H-1](#h-1-fees-owed-to-collection-referrer-are-sent-to-mint-referrer-instead) | Fees owed to collection referrer are sent to mint referrer instead | High |
| [M-1](#m-1-excess-eth-can-be-stolen-since-it-is-refunded-from-the-incorrect-contract) | Excess ETH can be stolen since it is refunded from the incorrect contract | Medium |
| [M-2](#m-2-fees-owed-to-collection-referrer-are-sent-to-mint-referrer-instead) | `TitlesGraph::acknowledgeEdge` and `TitlesGraph::unacknowledgeEdge` are susceptible to front-run attacks | Medium |
---

## [H-1] Fees owed to collection referrer are sent to mint referrer instead

## Summary

When protocol fees are split, the fees meant for the collection referrer are sent to the mint referrer instead. Collection referrer will not be able to receive any fees since the mint referrer takes them all.

## Vulnerability Detail

Fee route is created by an admin:

FeeManager::createRoute #L158-159
```javascript
    /// @param referrer_ The address of the referrer to receive a share of the fee.
    function createRoute(
        IEdition edition_,
        uint256 tokenId_,
        Target[] calldata attributions_,
        address referrer_
    ) external onlyOwnerOrRoles(ADMIN_ROLE) returns (Target memory receiver) {
        Target memory creator = edition_.node(tokenId_).creator;

        if (attributions_.length == 0) {
            receiver = creator;
        } else {
            (address[] memory targets, uint256[] memory revshares) = _buildSharesAndTargets(
                creator, attributions_, edition_.feeStrategy(tokenId_).revshareBps
            );

            receiver = Target({
                target: splitFactory.createSplit(
                    SplitV2Lib.Split({
                        recipients: targets,
                        allocations: revshares,
                        totalAllocation: 1e6,
                        distributionIncentive: 0
                    }),
                    address(this),
                    creator.target
                    ),
                chainId: creator.chainId
            });
        }

        _feeReceivers[getRouteId(edition_, tokenId_)] = receiver;
        // @audit collection referrer address set here
@>      referrers[edition_] = referrer_;
    }
```

When tokens are minted (i.e, via Edition::mint), FeeManager::collectMintFee is called, where a call to the internal _collectMintFee is made:

FeeManager::_collectMintFee #L407-408
```javascript
    function _collectMintFee(
        IEdition edition_,
        uint256 tokenId_,
        uint256 amount_,
        address payer_,
        address referrer_,
        Fee memory fee_
    ) internal {
        .
        .
        .

        // @audit split shares here
        uint256 referrerShare =
            _splitProtocolFee(edition_, fee_.asset, protocolShare, payer_, referrer_);
        emit FeeCollected(address(edition_), tokenId_, fee_.asset, fee_.amount, referrerShare);
    }
```

FeeManager::_splitProtocolFee #L438
```javascript
    function _splitProtocolFee(
        IEdition edition_,
        address asset_,
        uint256 amount_,
        address payer_,
        address referrer_
    ) internal returns (uint256 referrerShare) {
        uint256 mintReferrerShare = getMintReferrerShare(amount_, referrer_);
        // @audit collection referrer share calculated here
@>      uint256 collectionReferrerShare = getCollectionReferrerShare(amount_, referrers[edition_]);
        referrerShare = mintReferrerShare + collectionReferrerShare;

        _route(
            Fee({asset: asset_, amount: amount_ - referrerShare}),
            Target({target: protocolFeeReceiver, chainId: block.chainid}),
            payer_
        );

        _route(
            Fee({asset: asset_, amount: mintReferrerShare}),
            Target({target: referrer_, chainId: block.chainid}),
            payer_
        );

        // @audit the share is sent to mint referrer instead of collection referrer
        _route(
            Fee({asset: asset_, amount: collectionReferrerShare}),
@>          Target({target: referrer_, chainId: block.chainid}),
            payer_
        );
    }
```

As you can see, target address is set as referrer_, which in this case is the mint referrer, instead of the collection referrer. Collection referrer receives 0 fees since it is taken by mint referrer.

FeeManager::_route
```javascript
    function _route(Fee memory fee_, Target memory feeReceiver_, address feePayer_) internal {
        if (block.chainid != feeReceiver_.chainId) revert NotRoutable();
        if (fee_.amount == 0) return;

@>      _transfer(fee_.asset, fee_.amount, feePayer_, feeReceiver_.target);
    }
```

FeeManager::_transfer
```javascript
    function _transfer(address asset_, uint256 amount_, address from_, address to_) internal {
        if (asset_ == ETH_ADDRESS) {
            to_.safeTransferETH(amount_);
        } else {
            asset_.safeTransferFrom(from_, to_, amount_);
        }
    }
```

## Impact

As mentioned above, collection referrer does not receive owed fees and instead goes to mint referrer.

## Code Snippet

https://github.com/sherlock-audit/2024-04-titles/blob/main/wallflower-contract-v2/src/fees/FeeManager.sol#L158-L159

https://github.com/sherlock-audit/2024-04-titles/blob/main/wallflower-contract-v2/src/fees/FeeManager.sol#L407-L408

## Tools Used
Manual Review.

## Recommendation
Change the target address when routing the collectionReferrerShare

```javascript
    function _splitProtocolFee(
        IEdition edition_,
        address asset_,
        uint256 amount_,
        address payer_,
        address referrer_
    ) internal returns (uint256 referrerShare) {
        // The creation and mint referrers earn 25% and 50% of the protocol's share respectively, if applicable
        uint256 mintReferrerShare = getMintReferrerShare(amount_, referrer_);
        uint256 collectionReferrerShare = getCollectionReferrerShare(amount_, referrers[edition_]);
        referrerShare = mintReferrerShare + collectionReferrerShare;

        _route(
            Fee({asset: asset_, amount: amount_ - referrerShare}),
            Target({target: protocolFeeReceiver, chainId: block.chainid}),
            payer_
        );

        _route(
            Fee({asset: asset_, amount: mintReferrerShare}),
            Target({target: referrer_, chainId: block.chainid}),
            payer_
        );

        _route(
            Fee({asset: asset_, amount: collectionReferrerShare}),
-           Target({target: referrer_, chainId: block.chainid}),
+           Target({target: referrers[edition_], chainId: block.chainid}),
            payer_
        );
    }
```

## [M-1] Excess ETH can be stolen since it is refunded from the incorrect contract

## Summary

When minting tokens from the Edition contract, the FeeManager contract is called to collect the fees based on the amount of ETH sent by the caller. At the end of the mint call, Edition::_refundExcess() is called to refund any excess ETH to the caller. However, ETH was sent to the FeeManager contract, which now has the excess, not the Edition contract. Therefore the excess will be in FeeManager, and excess ETH will not be refunded.

A malicious actor can take advantage of this by minting new tokens and using the excess fees within FeeManager to pay for the fees, or taking a portion of the excess by specifying their own address as the referrer upon mint calls.

## Vulnerability Detail

Edition::mint #L228
```javascript
    function mint(
        address to_,
        uint256 tokenId_,
        uint256 amount_,
        address referrer_,
        bytes calldata data_
    ) external payable override {
@>      FEE_MANAGER.collectMintFee{value: msg.value}(
            this, tokenId_, amount_, msg.sender, referrer_, works[tokenId_].strategy
        );

        _issue(to_, tokenId_, amount_, data_);
@>      _refundExcess();
    }
```
When this function is called, the msg.value is sent to the FeeManager contract via collectMintFee:

FeeManager::collectMintFee #L366
```javascript
    function collectMintFee(
        IEdition edition_,
        uint256 tokenId_,
        uint256 amount_,
        address payer_,
        address referrer_
    ) external payable {
        _collectMintFee(
            edition_, tokenId_, amount_, payer_, referrer_, getMintFee(edition_, tokenId_, amount_)
        );
    }
    function _collectMintFee(
        IEdition edition_,
        uint256 tokenId_,
        uint256 amount_,
        address payer_,
        address referrer_,
        Fee memory fee_
    ) internal {
        if (fee_.amount == 0) return;

        .
        .
        .

        uint256 protocolFee = protocolFlatFee * amount_;
        uint256 protocolShare;
        if (fee_.amount == protocolFee) {
            protocolShare = protocolFee * protocolFeeshareBps / MAX_BPS;
        } else {
            protocolShare = protocolFee;
        }
        
        // @audit this call proceeds to transfer ETH to fee receiver
        _route(
            Fee({asset: fee_.asset, amount: fee_.amount - protocolShare}),
            _feeReceivers[getRouteId(edition_, tokenId_)],
            payer_
        );
        
        // @audit this call proceeds to transfer ETH to referrer and protocol
        uint256 referrerShare =
            _splitProtocolFee(edition_, fee_.asset, protocolShare, payer_, referrer_);
        emit FeeCollected(address(edition_), tokenId_, fee_.asset, fee_.amount, referrerShare);
    }
```
Fees are sent to protocol and referrer. Note that an arbitrary amount_ can be passed in.

At the end of the mint call, an attempt to refund excess ETH to the caller is made:

Edition::_refundExcess #L512
```javascript
    function _refundExcess() internal {
        if (msg.value > 0 && address(this).balance > 0) {
            msg.sender.safeTransferETH(address(this).balance);
        }
    }
```
However, the Edition contract no longer has excess since the amount msg.value was sent to FeeManager.

A malicious actor can exploit this the following ways:

Call mint and specify excess ETH as amount_ which will be used to the pay the protocol and referrer fees, effectively paying their fees with other users ETH

Call mint and specify their own address as the referrer, effectively taking a portion of the excess tokens

## Impact

Excess ETH stolen, allowing the above scenarios.

## Code Snippet

https://github.com/sherlock-audit/2024-04-titles/blob/main/wallflower-contract-v2/src/fees/FeeManager.sol#L366

https://github.com/sherlock-audit/2024-04-titles/blob/main/wallflower-contract-v2/src/fees/FeeManager.sol#L412

https://github.com/sherlock-audit/2024-04-titles/blob/main/wallflower-contract-v2/src/fees/FeeManager.sol#L448-L467

## Tools Used
Manual Review.

## Recommendation

Perhaps send the excess back to the Edition contract from FeeManager upon minting.

## [M-2] Fees owed to collection referrer are sent to mint referrer instead

## Summary

`TitlesGraph::acknowledgeEdge` and `TitlesGraph::unacknowledgeEdge` and both susceptible to front-run attacks.

When a call to acknowledgeEdge is made, an attacker can extract the parameters, including the signature, and call unacknowledgeEdge instead. When the user's call to acknowledgeEdge is executed, it will revert since the signature has already been used, therefore user will not be able to acknowledge the edge. This can be done for unacknowledgeEdge as well, effectively causing DoS of acknowledging and unacknowledging edges via front-run.

## Vulnerability Detail

TitlesGraph::acknowledgeEdge #L118
```javascript
    function acknowledgeEdge(bytes32 edgeId_, bytes calldata data_, bytes calldata signature_)
        external
@>      checkSignature(edgeId_, data_, signature_)
        returns (Edge memory edge)
    {
        return _setAcknowledged(edgeId_, data_, true);
    }
```

TitlesGraph::unacknowledgeEdge #L146
```javascript
    function unacknowledgeEdge(bytes32 edgeId_, bytes calldata data_, bytes calldata signature_)
        external
@>      checkSignature(edgeId_, data_, signature_)
        returns (Edge memory edge)
    {
        return _setAcknowledged(edgeId_, data_, false);
    }
```
TitlesGraph::checkSignature
```javascript
    modifier checkSignature(bytes32 edgeId, bytes calldata data, bytes calldata signature) {
        bytes32 digest = _hashTypedData(keccak256(abi.encode(ACK_TYPEHASH, edgeId, data)));
        if (
            !edges[edgeId].to.creator.target.isValidSignatureNowCalldata(digest, signature)
                || _isUsed[keccak256(signature)]
        ) {
@>          revert Unauthorized();
        }
        _;
@>      _isUsed[keccak256(signature)] = true;
    }
```

Both functions require signatures that is checked via the checkSignature modifier. If the signature has already been used, the call will revert. The problem is that both function calls can be front-run, allowing the following scenarios:

unacknowledgeEdge front-run: Attacker extracts parameters and calls acknowledgeEdge with the same signature. Once the call to unacknowledgeEdge is executed, it will revert since the signature has already been used. The caller will not be able to unacknowledge the edge.

acknowledgeEdge front-run: Attacker extracts parameters and calls unacknowledgeEdge with the same signature. Once the call to acknowledgeEdge is executed, it will revert since the signature has already been used. The caller will not be able to acknowledge the edge.

## Impact

Denial of Service of acknowledging and unacknowledging edges, causing discrepancies and manipulation with the status of edges.

## Code Snippet

https://github.com/sherlock-audit/2024-04-titles/blob/main/wallflower-contract-v2/src/graph/TitlesGraph.sol#L118

https://github.com/sherlock-audit/2024-04-titles/blob/main/wallflower-contract-v2/src/graph/TitlesGraph.sol#L146

https://github.com/sherlock-audit/2024-04-titles/blob/main/wallflower-contract-v2/src/graph/TitlesGraph.sol#L40-L50

https://github.com/sherlock-audit/2024-04-titles/blob/main/wallflower-contract-v2/src/graph/TitlesGraph.sol#L200

## Tools Used
Manual Review.

## Recommendation
Consider implementing a check to see if caller is the signer
