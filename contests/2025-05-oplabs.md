# OP Labs / safe-extensions

[OP Labs](https://cantina.xyz/code/d47f8096-8858-437d-a9f5-2fe85ac9b95e/overview) has developed Safe Modules and a Safe Guard for use on the Security Council safe which is involved in upgrades to OP Mainnet and other chains in the Superchain.

## Audit Findings Summary

| ID | Title | Severity |
|----|----------|----------|
| [M-1](#m-1-livenessguardchecktransaction-does-not-update-lastlive-for-all-signers-of-a-safe-transaction) | LivenessGuard::checkTransaction does not update lastLive for all signers of a Safe transaction | Medium |
| [L-1](#l-1-safe-transaction-executions-may-not-have-enough-gas-to-execute-transactions-in-certain-cases) | Safe transaction executions may not have enough gas to execute transactions in certain cases | Low |
---

## [M-1] LivenessGuard::checkTransaction does not update lastLive for all signers of a Safe transaction

## Description
The Security Council Safe document mentions the following:

Liveness Security Properties
The following security properties must be upheld:

In the guard
Signatures are assigned to the correct signer.
Non-signers are unable to create a record of having signed.
An owner cannot be censored or griefed such that their signing is not recorded.
The purpose of the guard LivenessGuard is to ensure that the timestamp of the owners who are actively participating and signing transactions are updated.

If the last time an owner signed has passed LIVENESS_INTERVAL, anyone can remove the owner from the Safe by calling LivenessModule::removeOwners.

The problem is that there is a flaw in LivenessGuard::checkTransaction where some signers will not have their liveness timestamp updated. Due to this issue, they may be erroneously removed from the Safe.

## Proof of Concept
Before transactions are executed, a call to LivenessGuard::checkTransaction is made from the Safe contract as shown here.

LivenessGuard::checkTransaction #L69
```javascript
/// @notice Records the most recent time which any owner has signed a transaction.
    /// @dev Called by the Safe contract before execution of a transaction.
    function checkTransaction(
        address to,
        uint256 value,
        bytes memory data,
        Enum.Operation operation,
        uint256 safeTxGas,
        uint256 baseGas,
        uint256 gasPrice,
        address gasToken,
        address payable refundReceiver,
        bytes memory signatures,
        address msgSender
    )
        external
    {
        msgSender; // silence unused variable warning
        _requireOnlySafe();

        // Cache the set of owners prior to execution.
        // This will be used in the checkAfterExecution method.
        address[] memory owners = SAFE.getOwners();
        for (uint256 i = 0; i < owners.length; i++) {
            ownersBefore.add(owners[i]);
        }

        // This call will reenter to the Safe which is calling it. This is OK because it is only reading the
        // nonce, and using the getTransactionHash() method.
        bytes32 txHash = SAFE.getTransactionHash({
            to: to,
            value: value,
            data: data,
            operation: operation,
            safeTxGas: safeTxGas,
            baseGas: baseGas,
            gasPrice: gasPrice,
            gasToken: gasToken,
            refundReceiver: refundReceiver,
            _nonce: SAFE.nonce() - 1
        });

@>      uint256 threshold = SAFE.getThreshold(); //@audit this will be the number of `requiredSignatues`
@>      address[] memory signers =
            SafeSigners.getNSigners({ dataHash: txHash, signatures: signatures, requiredSignatures: threshold });

        for (uint256 i = 0; i < signers.length; i++) {
            lastLive[signers[i]] = block.timestamp;
            emit OwnerRecorded(signers[i]);
        }
    }
Let's take a look at the call to SafeSigners::getNSigners #L45

library SafeSigners {
    .
    .
    .

    function getNSigners(
        bytes32 dataHash,
        bytes memory signatures,
@>      uint256 requiredSignatures
    )
        internal
        pure
        returns (address[] memory _owners)
    {
        _owners = new address[](requiredSignatures);

        address currentOwner;
        uint8 v;
        bytes32 r;
        bytes32 s;
        uint256 i;
@>      for (i = 0; i < requiredSignatures; i++) {
            (v, r, s) = signatureSplit(signatures, i);
            if (v == 0) {
                // If v is 0 then it is a contract signature
                // When handling contract signatures the address of the contract is encoded into r
                currentOwner = address(uint160(uint256(r)));
            } else if (v == 1) {
                // If v is 1 then it is an approved hash
                // When handling approved hashes the address of the approver is encoded into r
                currentOwner = address(uint160(uint256(r)));
            } else if (v > 30) {
                // If v > 30 then default va (27,28) has been adjusted for eth_sign flow
                // To support eth_sign and similar we adjust v and hash the messageHash with the Ethereum message prefix
                // before applying ecrecover
                currentOwner =
                    ecrecover(keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", dataHash)), v - 4, r, s);
            } else {
                // Default is the ecrecover flow with the provided data hash
                // Use ecrecover with the messageHash for EOA signatures
                currentOwner = ecrecover(dataHash, v, r, s);
            }
            _owners[i] = currentOwner;
        }
    }
}
```

Notice how we only loop through requiredSignatures.

requiredSignatures is equivalent to the threshold, which is expressed as (numOwners * threshold_percentage + 99) / 100.

LivenessModule::getThreshold
```javascript
function getRequiredThreshold(uint256 _numOwners) public view returns (uint256 threshold_) {
@>      threshold_ = (_numOwners * THRESHOLD_PERCENTAGE + 99) / 100;
    }
```

Let's say the threshold_percentage = 75 as shown here.

So if there are N = 9 owners, we have threshold = 7. Therefore, the requiredSignatures will be 7 and 7 signers will be returned:
```javascript
address[] memory signers =
            SafeSigners.getNSigners({ dataHash: txHash, signatures: signatures, requiredSignatures: threshold });
        for (uint256 i = 0; i < signers.length; i++) {
@>          lastLive[signers[i]] = block.timestamp;
            emit OwnerRecorded(signers[i]);
        }
```
These 7 signers will have their lastLive mapping updated.

However, if all 9 owners signed, there will be two owners that despite signing, will not have their liveness updated.

Therefore, despite signing transactions, there will be some owners who will not have their liveness updated, breaking a core protocol invariant.

To make matters worse, since their liveness was not updated despite signing, the LIVENESS_INTERVAL corresponding to the respective owner's lastLive may pass.

This will allow anyone to call LivenessModule::removeOwners to remove them from the Safe:
```javascript
/// @notice Checks if the owner can be removed
    /// @param _owner The owner to be removed
    /// @return canRemove_ bool indicating if the owner can be removed
    function canRemove(address _owner) public view returns (bool canRemove_) {
        require(SAFE.isOwner(_owner), "LivenessModule: the owner to remove must be an owner of the Safe");
@>      canRemove_ = LIVENESS_GUARD.lastLive(_owner) + LIVENESS_INTERVAL < block.timestamp;
    }

    /// @notice This function can be called by anyone to remove a set of owners that have not signed a transaction
    ///         during the liveness interval. If the number of owners drops below the minimum, then all owners
    ///         must be removed.
    /// @param _previousOwners The previous owners in the linked list of owners
    /// @param _ownersToRemove The owners to remove
    function removeOwners(address[] memory _previousOwners, address[] memory _ownersToRemove) external {
        require(_previousOwners.length == _ownersToRemove.length, "LivenessModule: arrays must be the same length");

        // Initialize the ownersCount count to the current number of owners, so that we can track the number of
        // owners in the Safe after each removal. The Safe will revert if an owner cannot be removed, so it is safe
        // keep a local count of the number of owners this way.
        uint256 ownersCount = SAFE.getOwners().length;
        for (uint256 i = 0; i < _previousOwners.length; i++) {
            // Validate that the owner can be removed, which means that either:
            //   1. the ownersCount is now less than MIN_OWNERS, in which case all owners should be removed regardless
            //      of liveness,
            //   2. the owner has not signed a transaction during the liveness interval.
            if (ownersCount >= MIN_OWNERS) {
@>              require(canRemove(_ownersToRemove[i]), "LivenessModule: the owner to remove has signed recently");
            }

            // Pre-emptively update our local count of the number of owners.
            // This is safe because _removeOwner will bubble up any revert from the Safe if the owner cannot be removed.
            ownersCount--;

            // We now attempt remove the owner from the safe.
            _removeOwner({
                _prevOwner: _previousOwners[i],
                _ownerToRemove: _ownersToRemove[i],
                _newOwnersCount: ownersCount
            });

            // when all owners are removed and the sole owner is the fallback owner, the
            // ownersCount variable will be incorrectly set to zero.
            // This reflects the fact that all prior owners have been removed. The loop should naturally exit at this
            // point, but for safety we detect this condition and force the loop to terminate.
            if (ownersCount == 0) {
                break;
            }
        }
        _verifyFinalState();
    }
```

To summarize: Only requiredSignatures number of signatures are updated from Safe transactions, which is equivalent to the threshold. Therefore if more than requiredSignatures number of owners sign a transaction, some of the owners will not have their last liveness updated. If LIVENESS_INTERVAL passes, they will be removed from the Safe.

## Recommendation
Ensure that all of the signers are processed when the call to LivenessGuard::checkTransaction is made, not just requiredSignatures number of signers.

## [L-1] Safe transaction executions may not have enough gas to execute transactions in certain cases

## Description
When transactions are signed by owners of a Safe account, the LivenessGuard::checkTransaction callback is executed. After the callback is executed, the Safe contract proceeds to check if there is at least a specific amount of gas left to proceed with the transaction, if not, the entire call will revert.

Due to the functionality within LivenessGuard::checkTransaction, there are cases where this may be true, causing denial of service of Safe transaction executions.

## Proof of Concept
When transactions are executed, the Safe contract will first verify the signatures within the contract:

Safe::execTransaction https://github.com/safe-global/safe-smart-account/blob/e870f514ad34cd9654c72174d6d4a839e3c6639f/contracts/Safe.sol#L172
```javascript
function execTransaction(
        address to,
        uint256 value,
        bytes calldata data,
        Enum.Operation operation,
        uint256 safeTxGas,
        uint256 baseGas,
        uint256 gasPrice,
        address gasToken,
        address payable refundReceiver,
        bytes memory signatures
    ) public payable virtual returns (bool success) {
        bytes32 txHash;
        // Use scope here to limit variable lifetime and prevent `stack too deep` errors
        {
            bytes memory txHashData = encodeTransactionData(
                // Transaction info
                to,
                value,
                data,
                operation,
                safeTxGas,
                // Payment info
                baseGas,
                gasPrice,
                gasToken,
                refundReceiver,
                // Signature info
                nonce
            );
            // Increase nonce and execute transaction.
            nonce++;
            txHash = keccak256(txHashData);
@>          checkSignatures(txHash, txHashData, signatures);
        }
```
Safe::checkSignatures, Safe::checkNSignatures https://github.com/safe-global/safe-smart-account/blob/e870f514ad34cd9654c72174d6d4a839e3c6639f/contracts/Safe.sol#L257-L334
```javascript
function checkSignatures(bytes32 dataHash, bytes memory data, bytes memory signatures) public view {
        // Load threshold to avoid multiple storage loads
        uint256 _threshold = threshold;
        // Check that a threshold is set
        require(_threshold > 0, "GS001");
@>      checkNSignatures(dataHash, data, signatures, _threshold);
    }

    /**
     * @notice Checks whether the signature provided is valid for the provided data and hash. Reverts otherwise.
     * @dev Since the EIP-1271 does an external call, be mindful of reentrancy attacks.
     * @param dataHash Hash of the data (could be either a message hash or transaction hash)
     * @param data That should be signed (this is passed to an external validator contract)
     * @param signatures Signature data that should be verified.
     *                   Can be packed ECDSA signature ({bytes32 r}{bytes32 s}{uint8 v}), contract signature (EIP-1271) or approved hash.
     * @param requiredSignatures Amount of required valid signatures.
     */
    function checkNSignatures(bytes32 dataHash, bytes memory data, bytes memory signatures, uint256 requiredSignatures) public view {
        // Check that the provided signature data is not too short
        require(signatures.length >= requiredSignatures.mul(65), "GS020");
        // There cannot be an owner with address 0.
        address lastOwner = address(0);
        address currentOwner;
        uint8 v;
        bytes32 r;
        bytes32 s;
        uint256 i;
        for (i = 0; i < requiredSignatures; i++) {
            (v, r, s) = signatureSplit(signatures, i);
            if (v == 0) {
                require(keccak256(data) == dataHash, "GS027");
                // If v is 0 then it is a contract signature
                // When handling contract signatures the address of the contract is encoded into r
                currentOwner = address(uint160(uint256(r)));

                // Check that signature data pointer (s) is not pointing inside the static part of the signatures bytes
                // This check is not completely accurate, since it is possible that more signatures than the threshold are send.
                // Here we only check that the pointer is not pointing inside the part that is being processed
                require(uint256(s) >= requiredSignatures.mul(65), "GS021");

                // Check that signature data pointer (s) is in bounds (points to the length of data -> 32 bytes)
                require(uint256(s).add(32) <= signatures.length, "GS022");

                // Check if the contract signature is in bounds: start of data is s + 32 and end is start + signature length
                uint256 contractSignatureLen;
                // solhint-disable-next-line no-inline-assembly
                assembly {
                    contractSignatureLen := mload(add(add(signatures, s), 0x20))
                }
                require(uint256(s).add(32).add(contractSignatureLen) <= signatures.length, "GS023");

                // Check signature
                bytes memory contractSignature;
                // solhint-disable-next-line no-inline-assembly
                assembly {
                    // The signature data for contract signatures is appended to the concatenated signatures and the offset is stored in s
                    contractSignature := add(add(signatures, s), 0x20)
                }
                require(ISignatureValidator(currentOwner).isValidSignature(data, contractSignature) == EIP1271_MAGIC_VALUE, "GS024");
            } else if (v == 1) {
                // If v is 1 then it is an approved hash
                // When handling approved hashes the address of the approver is encoded into r
                currentOwner = address(uint160(uint256(r)));
                // Hashes are automatically approved by the sender of the message or when they have been pre-approved via a separate transaction
                require(msg.sender == currentOwner || approvedHashes[currentOwner][dataHash] != 0, "GS025");
            } else if (v > 30) {
                // If v > 30 then default va (27,28) has been adjusted for eth_sign flow
                // To support eth_sign and similar we adjust v and hash the messageHash with the Ethereum message prefix before applying ecrecover
                currentOwner = ecrecover(keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", dataHash)), v - 4, r, s);
            } else {
                // Default is the ecrecover flow with the provided data hash
                // Use ecrecover with the messageHash for EOA signatures
                currentOwner = ecrecover(dataHash, v, r, s);
            }
            require(currentOwner > lastOwner && owners[currentOwner] != address(0) && currentOwner != SENTINEL_OWNERS, "GS026");
            lastOwner = currentOwner;
        }
    }
```
The purpose of showing this is to display that there can be quite some gas consumed from this, especially if the number of owners is large. This is because the checkNSignatures function loops requiredSignatures times, which is equivalent to the threshold, which is expressed as (numOwners * threshold_percentage + 99) / 100

LivenessModule::getThreshold
```javascript
function getRequiredThreshold(uint256 _numOwners) public view returns (uint256 threshold_) {
@>      threshold_ = (_numOwners * THRESHOLD_PERCENTAGE + 99) / 100;
    }
```
Let's say the threshold_percentage = 75 as shown here.

So if there are N = 9 owners, we have threshold = 7. Therefore, the requiredSignatures is 7 in this case, causing some gas to be consumed from this call.

Once the signatures are verified, a call to LivenessGuard::checkTransaction is made https://github.com/safe-global/safe-smart-account/blob/e870f514ad34cd9654c72174d6d4a839e3c6639f/contracts/Safe.sol#L177
```javascript
address guard = getGuard();
        {
            if (guard != address(0)) {
@>              Guard(guard).checkTransaction(
                    // Transaction info
                    to,
                    value,
                    data,
                    operation,
                    safeTxGas,
                    // Payment info
                    baseGas,
                    gasPrice,
                    gasToken,
                    refundReceiver,
                    // Signature info
                    signatures,
                    msg.sender
                );
            }
        }
```
LivenessGuard::checkTransaction #L69
```javascript
/// @notice Records the most recent time which any owner has signed a transaction.
    /// @dev Called by the Safe contract before execution of a transaction.
    function checkTransaction(
        address to,
        uint256 value,
        bytes memory data,
        Enum.Operation operation,
        uint256 safeTxGas,
        uint256 baseGas,
        uint256 gasPrice,
        address gasToken,
        address payable refundReceiver,
        bytes memory signatures,
        address msgSender
    )
        external
    {
        msgSender; // silence unused variable warning
        _requireOnlySafe();

        // Cache the set of owners prior to execution.
        // This will be used in the checkAfterExecution method.
        address[] memory owners = SAFE.getOwners();
        for (uint256 i = 0; i < owners.length; i++) {
            ownersBefore.add(owners[i]);
        }

        // This call will reenter to the Safe which is calling it. This is OK because it is only reading the
        // nonce, and using the getTransactionHash() method.
        bytes32 txHash = SAFE.getTransactionHash({
            to: to,
            value: value,
            data: data,
            operation: operation,
            safeTxGas: safeTxGas,
            baseGas: baseGas,
            gasPrice: gasPrice,
            gasToken: gasToken,
            refundReceiver: refundReceiver,
            _nonce: SAFE.nonce() - 1
        });

        uint256 threshold = SAFE.getThreshold();
 @>     address[] memory signers =
            SafeSigners.getNSigners({ dataHash: txHash, signatures: signatures, requiredSignatures: threshold });

        for (uint256 i = 0; i < signers.length; i++) {
            lastLive[signers[i]] = block.timestamp;
            emit OwnerRecorded(signers[i]);
        }
    }
```

Here, we essentially repeat the exact same process as when the signatures were verified just before this call. A call to SafeSigners::getNSigners is made with the same requiredSignatures value.

SafeSigners::getNSigners #L45
```javascript
function getNSigners(
        bytes32 dataHash,
        bytes memory signatures,
        uint256 requiredSignatures
    )
        internal
        pure
        returns (address[] memory _owners)
    {
        _owners = new address[](requiredSignatures);

        address currentOwner;
        uint8 v;
        bytes32 r;
        bytes32 s;
        uint256 i;
        for (i = 0; i < requiredSignatures; i++) {
            (v, r, s) = signatureSplit(signatures, i);
            if (v == 0) {
                // If v is 0 then it is a contract signature
                // When handling contract signatures the address of the contract is encoded into r
                currentOwner = address(uint160(uint256(r)));
            } else if (v == 1) {
                // If v is 1 then it is an approved hash
                // When handling approved hashes the address of the approver is encoded into r
                currentOwner = address(uint160(uint256(r)));
            } else if (v > 30) {
                // If v > 30 then default va (27,28) has been adjusted for eth_sign flow
                // To support eth_sign and similar we adjust v and hash the messageHash with the Ethereum message prefix
                // before applying ecrecover
                currentOwner =
                    ecrecover(keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", dataHash)), v - 4, r, s);
            } else {
                // Default is the ecrecover flow with the provided data hash
                // Use ecrecover with the messageHash for EOA signatures
                currentOwner = ecrecover(dataHash, v, r, s);
            }
            _owners[i] = currentOwner;
        }
    }
```
The signatures are being checked again, indentical to how it was checked at the start of the call..

The purpose of performing this again is to upgrade the lastLive mapping of the signers, to display that they are active. But we can see that, especially if number of owners gets larger, it is quite gas intensive.

Once the callback is complete, the Safe contract has a check for the gasleft() before it proceeds to execute the transaction.

Safe::execTransaction https://github.com/safe-global/safe-smart-account/blob/e870f514ad34cd9654c72174d6d4a839e3c6639f/contracts/Safe.sol#L195C1-L215C10
```javascript
// We require some gas to emit the events (at least 2500) after the execution and some to perform code until the execution (500)
        // We also include the 1/64 in the check that is not send along with a call to counteract potential shortings because of EIP-150
@>      require(gasleft() >= ((safeTxGas * 64) / 63).max(safeTxGas + 2500) + 500, "GS010");
        // Use scope here to limit variable lifetime and prevent `stack too deep` errors
        {
            uint256 gasUsed = gasleft();
            // If the gasPrice is 0 we assume that nearly all available gas can be used (it is always more than safeTxGas)
            // We only substract 2500 (compared to the 3000 before) to ensure that the amount passed is still higher than safeTxGas
            success = execute(to, value, data, operation, gasPrice == 0 ? (gasleft() - 2500) : safeTxGas);
            gasUsed = gasUsed.sub(gasleft());
            // If no safeTxGas and no gasPrice was set (e.g. both are 0), then the internal tx is required to be successful
            // This makes it possible to use `estimateGas` without issues, as it searches for the minimum gas where the tx doesn't revert
            require(success || safeTxGas != 0 || gasPrice != 0, "GS013");
            // We transfer the calculated tx costs to the tx.origin to avoid sending it to intermediate contracts that have made calls
            uint256 payment = 0;
            if (gasPrice > 0) {
                payment = handlePayment(gasUsed, baseGas, gasPrice, gasToken, refundReceiver);
            }
            if (success) emit ExecutionSuccess(txHash, payment);
            else emit ExecutionFailure(txHash, payment);
        }
```
As you can see, plenty of gas was already consumed from checking the signatures twice. The amount of gasleft() may be too low, causing the call to revert.

## Recommendation
Perhaps set a maximum owner/threshold cap to only a few owners, so that enough gas is left after the callbacks are executed.
