# Renzo

A [protocol](https://code4rena.com/audits/2024-04-renzo) that abstracts all staking complexity from the end-user and enables easy collaboration with EigenLayer node operators and a Validated Services (AVSs).

## Audit Findings Summary

| ID | Title | Severity |
|----|----------|----------|
| [H-1](#h-1-operatordelegatorcompletewithdrawals-will-revert-when-token-is-not-native-eth-causing-blockage-of-manual-withdrawals-via-eigenlayer) | `OperatorDelegator::completeWithdrawals` will revert when token is not native ETH, causing blockage of manual withdrawals via `EigenLayer` | High |
| [H-2](#h-2-minting-ezeth-does-not-account-for-tokens-queued-for-withdrawal-via-withdrawqueuewithdraw) | Minting `ezETH` does not account for tokens queued for withdrawal via `WithdrawQueue::withdraw` | High |
| [M-1](#m-1-deposit-and-withdraw-should-have-slippage-protection) | `deposit` and `withdraw` should have slippage protection | Medium |
---

## [H-1] `OperatorDelegator::completeWithdrawals` will revert when token is not native ETH, causing blockage of manual withdrawals via `EigenLayer`

# Vulnerability details

## Impact
Withdrawal in the `Renzo` protocol works the following way:
```javascript
The withdrawQueue contract get filled by 3 ways ->
1. New Deposits
2. Daily Rewards Coming in the Protocol.
3. Manual withdrawal from EigenLayer. Permissioned call from OperatorDelegator.
-> If options 1 and 2 are not sufficient to fulfil withdraw requests of Users then admin accounts will manually unstake from EigenLayer periodically through 2 step process (in case of ETH 3 steps) -
OperatorDelegator.queueWithdrawals
2.a. OperatorDelegator.verifyAndProcessWithdrawals (for ETH full withdrawal from EigenLayer which requires proof submission generated Offchain ).
2.b. OperatorDelegator.completeQueuedWithdrawals.
```
When withdrawing manually from `Eigenlayer`, the withdrawal is queued from `OperatorDelegator`. The final step is to call `OperatorDelegator::completeQueuedWithdrawals`. However, due to an issue regarding `access control`, this will revert when token is not `native ETH`. In addition, these tokens cannot be recovered and may be stuck in the `OperatorDelegator` contract.

## Proof of Concept
As mentioned above, the last step when withdrawing from `Eigenlayer` is to make the following call:

`OperatorDelegator::completeQueuedWithdrawals`
https://github.com/code-423n4/2024-04-renzo/blob/main/contracts/Delegation/OperatorDelegator.sol#L265
```javascript
/**
 * @notice  Complete the specified withdrawal,
 * @dev     permissioned call (onlyNativeEthRestakeAdmin)
 * @param   withdrawal  Withdrawal struct
 * @param   tokens  list of tokens to withdraw
 * @param   middlewareTimesIndex  is the index in the operator that the staker who triggered the withdrawal was delegated to's middleware times array
 */
function completeQueuedWithdrawal(
    IDelegationManager.Withdrawal calldata withdrawal,
    IERC20[] calldata tokens,
    uint256 middlewareTimesIndex
) external nonReentrant onlyNativeEthRestakeAdmin {
    uint256 gasBefore = gasleft();
    if (tokens.length != withdrawal.strategies.length) revert MismatchedArrayLengths();

    // complete the queued withdrawal from EigenLayer with receiveAsToken set to true
    delegationManager.completeQueuedWithdrawal(withdrawal, tokens, middlewareTimesIndex, true);

    IWithdrawQueue withdrawQueue = restakeManager.depositQueue().withdrawQueue();
    for (uint256 i; i < tokens.length; ) {
        if (address(tokens[i]) == address(0)) revert InvalidZeroInput();

        // deduct queued shares for tracking TVL
        queuedShares[address(tokens[i])] -= withdrawal.shares[i];

        // check if token is not Native ETH
@>          if (address(tokens[i]) != IS_NATIVE) {
            // Check the withdraw buffer and fill if below buffer target
            uint256 bufferToFill = withdrawQueue.getBufferDeficit(address(tokens[i]));

            // get balance of this contract
            uint256 balanceOfToken = tokens[i].balanceOf(address(this));
            if (bufferToFill > 0) {
                bufferToFill = (balanceOfToken <= bufferToFill) ? balanceOfToken : bufferToFill;

                // update amount to send to the operator Delegator
                balanceOfToken -= bufferToFill;

                // safe Approve for depositQueue
                tokens[i].safeApprove(address(restakeManager.depositQueue()), bufferToFill);

                // fill Withdraw Buffer via depositQueue
@>                  restakeManager.depositQueue().fillERC20withdrawBuffer(
                    address(tokens[i]),
                    bufferToFill
                );
            }

            // Deposit remaining tokens back to eigenLayer
            if (balanceOfToken > 0) {
                _deposit(tokens[i], balanceOfToken);
            }
        }
        unchecked {
            ++i;
        }
    }

    // emits the Withdraw Completed event with withdrawalRoot
    emit WithdrawCompleted(
        delegationManager.calculateWithdrawalRoot(withdrawal),
        withdrawal.strategies,
        withdrawal.shares
    );
    // record current spent gas
    _recordGas(gasBefore);
}
```

We can see that when `address(tokens[i]) != IS_NATIVE` a call to `restakeManager.depositQueue().fillERC20withdrawBuffer` is made.


`restakeManager.depositQueue()` returns the address of the `DepositQueue` contract and a call to `DepositQueue::fillERC20withdrawBuffer` is made:

`DepositQueue::fillERC20withdrawBuffer`
https://github.com/code-423n4/2024-04-renzo/blob/main/contracts/Deposits/DepositQueue.sol#L134
```javascript
function fillERC20withdrawBuffer(
    address _asset,
    uint256 _amount
@>  ) external nonReentrant onlyRestakeManager {
    if (_amount == 0 || _asset == address(0)) revert InvalidZeroInput();
    // safeTransfer from restake manager to this address
    IERC20(_asset).safeTransferFrom(msg.sender, address(this), _amount);
    // approve the token amount for withdraw queue
    IERC20(_asset).safeApprove(address(withdrawQueue), _amount);
    // call the withdraw queue to fill up the buffer
    withdrawQueue.fillERC20WithdrawBuffer(_asset, _amount);
}
```

However, we can clearly see that this is a permissioned call via `onlyRestakeManager` modifier:

`DepositQueue::onlyRestakeManager`
https://github.com/code-423n4/2024-04-renzo/blob/main/contracts/Deposits/DepositQueue.sol#L50
```javascript
/// @dev Allows only the RestakeManager address to call functions
modifier onlyRestakeManager() {
    if (msg.sender != address(restakeManager)) revert NotRestakeManager();
    _;
}
```

Since `DepositQueue::fillERC20withdrawBuffer` was called from the `OperatorDelegator` contract, that will be the address of `msg.sender`. We can see here that only the `RestakeManager` contract can call it:

`DepositQueue::setRestakeManager`
https://github.com/code-423n4/2024-04-renzo/blob/main/contracts/Deposits/DepositQueue.sol#L112
```javascript
/// @dev Sets the address of the RestakeManager contract
function setRestakeManager(IRestakeManager _restakeManager) external onlyRestakeManagerAdmin {
    if (address(_restakeManager) == address(0x0)) revert InvalidZeroInput();

@>      restakeManager = _restakeManager;

    emit RestakeManagerUpdated(_restakeManager);
}
```

Therefore this call will revert and `OperatorDelegator::completeQueuedWithdrawals` will revert.

To make matters worse, these tokens may be trapped in the contract:

`OperatorDelegator::recoverTokens`
https://github.com/code-423n4/2024-04-renzo/blob/main/contracts/Delegation/OperatorDelegator.sol#L446
```javascript
/**
 * @notice  Recover tokens accidentally sent to EigenPod
 * @dev     Only callable by admin
 * @param   tokenList  .
 * @param   amountsToWithdraw  .
 * @param   recipient  .
 */
function recoverTokens(
    IERC20[] memory tokenList,
    uint256[] memory amountsToWithdraw,
    address recipient
) external onlyNativeEthRestakeAdmin {
    eigenPod.recoverTokens(tokenList, amountsToWithdraw, recipient);
}
```

This is the only recovery function but it only recovers tokens accidentally sent to EigenPod, not tokens within `OperatorDelegator`.

## Tools Used
Manual Review.

## Recommended Mitigation Steps
Manage the access control of `DepositQueue::fillERC20withdrawBuffer` to allow calls from the `OperatorDelegator` contract.

## [H-2] Minting `ezETH` does not account for tokens queued for withdrawal via `WithdrawQueue::withdraw`

# Vulnerability details

## Impact
When users withdraw, their withdrawal is queued until `coolDownPeriod` has passed. The queued withdrawals are not accounted for when we calculate `totalTVL`, which is used to calculate the amount of `ezETH` to mint users when they deposit. Due to this issue, users will be minted an incorrect amount of `ezETH`.

## Proof of Concept
Users deposit via `RestakeManager::deposit`
https://github.com/code-423n4/2024-04-renzo/blob/main/contracts/RestakeManager.sol#L491
```javascript
   function deposit(
       IERC20 _collateralToken,
       uint256 _amount,
       uint256 _referralId
   ) public nonReentrant notPaused {
       // Verify collateral token is in the list - call will revert if not found
       uint256 tokenIndex = getCollateralTokenIndex(_collateralToken);

       // Get the TVLs for each operator delegator and the total TVL
       (
           uint256[][] memory operatorDelegatorTokenTVLs,
           uint256[] memory operatorDelegatorTVLs,
           uint256 totalTVL
@>      ) = calculateTVLs();

       // Get the value of the collateral token being deposited
       uint256 collateralTokenValue = renzoOracle.lookupTokenValue(_collateralToken, _amount);


       .
       .
       .


       // Calculate how much ezETH to mint
@>      uint256 ezETHToMint = renzoOracle.calculateMintAmount(
           totalTVL,
           collateralTokenValue,
           ezETH.totalSupply()
       );

       // Mint the ezETH
       ezETH.mint(msg.sender, ezETHToMint);

       // Emit the deposit event
       emit Deposit(msg.sender, _collateralToken, _amount, ezETHToMint, _referralId);
   }
```

The `totalTVL` returned by calculateTVLs() determines how much `ezETH` to mint to the user.

When users withdraw, they can call `WithdrawQueue::withdraw`
https://github.com/code-423n4/2024-04-renzo/blob/main/contracts/Withdraw/WithdrawQueue.sol#L206
```javascript
   function withdraw(uint256 _amount, address _assetOut) external nonReentrant {
         .
         .
         .

       // add withdraw request for msg.sender
@>      withdrawRequests[msg.sender].push(
           WithdrawRequest(
               _assetOut,
               withdrawRequestNonce,
               amountToRedeem,
               _amount,
               block.timestamp
           )
       );

       // add redeem amount to claimReserve of claim asset
       claimReserve[_assetOut] += amountToRedeem;

       emit WithdrawRequestCreated(
           withdrawRequestNonce,
           msg.sender,
           _assetOut,
           amountToRedeem,
           _amount,
           withdrawRequests[msg.sender].length - 1
       );
   }
```

When `cooldownPeriod` has passed, they can call `WithdrawQueue::claim`
https://github.com/code-423n4/2024-04-renzo/blob/main/contracts/Withdraw/WithdrawQueue.sol#L279-L312
```javascript
   function claim(uint256 withdrawRequestIndex) external nonReentrant {
       // check if provided withdrawRequest Index is valid
       if (withdrawRequestIndex >= withdrawRequests[msg.sender].length)
           revert InvalidWithdrawIndex();

       WithdrawRequest memory _withdrawRequest = withdrawRequests[msg.sender][
           withdrawRequestIndex
       ];
@>      if (block.timestamp - _withdrawRequest.createdAt < coolDownPeriod) revert EarlyClaim();

       // subtract value from claim reserve for claim asset
       claimReserve[_withdrawRequest.collateralToken] -= _withdrawRequest.amountToRedeem;

       // delete the withdraw request
       withdrawRequests[msg.sender][withdrawRequestIndex] = withdrawRequests[msg.sender][
           withdrawRequests[msg.sender].length - 1
       ];
       withdrawRequests[msg.sender].pop();

       // burn ezETH locked for withdraw request
       ezETH.burn(address(this), _withdrawRequest.ezETHLocked);

       // send selected redeem asset to user
       if (_withdrawRequest.collateralToken == IS_NATIVE) {
           payable(msg.sender).transfer(_withdrawRequest.amountToRedeem);
       } else {
           IERC20(_withdrawRequest.collateralToken).transfer(
               msg.sender,
               _withdrawRequest.amountToRedeem
           );
       }
       // emit the event
       emit WithdrawRequestClaimed(_withdrawRequest);
   }
```

After `coolDownPeriod` has passed, users can finalize their withdrawals. The problem is that during that time, the queued withdrawals are not accounted for when calculating the `totalTVL`.

This presents an issue when minting `ezETH` via `RestakeManager::deposit`, where users will be minted an incorrect amount of `ezETH`.

Let's take a closer look at the `totalTVL` calculation.

`RestakeManager::calculateTVLs`
https://github.com/code-423n4/2024-04-renzo/blob/main/contracts/RestakeManager.sol#L274
```javascript
function calculateTVLs() public view returns (uint256[][] memory, uint256[] memory, uint256) {
       uint256[][] memory operatorDelegatorTokenTVLs = new uint256[][](operatorDelegators.length);
       uint256[] memory operatorDelegatorTVLs = new uint256[](operatorDelegators.length);
       uint256 totalTVL = 0;

       // Iterate through the ODs
       uint256 odLength = operatorDelegators.length;

       // flag for withdrawal queue balance set
       bool withdrawQueueTokenBalanceRecorded = false;
       address withdrawQueue = address(depositQueue.withdrawQueue());

       // withdrawalQueue total value
       uint256 totalWithdrawalQueueValue = 0;

       for (uint256 i = 0; i < odLength; ) {
           // Track the TVL for this OD
           uint256 operatorTVL = 0;

           // Track the individual token TVLs for this OD - native ETH will be last item in the array
           uint256[] memory operatorValues = new uint256[](collateralTokens.length + 1);
           operatorDelegatorTokenTVLs[i] = operatorValues;

           // Iterate through the tokens and get the value of each
           uint256 tokenLength = collateralTokens.length;
           for (uint256 j = 0; j < tokenLength; ) {
               // Get the value of this token

               uint256 operatorBalance = operatorDelegators[i].getTokenBalanceFromStrategy(
                   collateralTokens[j]
               );

               // Set the value in the array for this OD
               operatorValues[j] = renzoOracle.lookupTokenValue(
                   collateralTokens[j],
                   operatorBalance
               );

               // Add it to the total TVL for this OD
               operatorTVL += operatorValues[j];

               // record token value of withdraw queue
               if (!withdrawQueueTokenBalanceRecorded) {
@>                  totalWithdrawalQueueValue += renzoOracle.lookupTokenValue(
                       collateralTokens[i],
                       collateralTokens[j].balanceOf(withdrawQueue)
                   );
               }

               unchecked {
                   ++j;
               }
           }

           // Get the value of native ETH staked for the OD
           uint256 operatorEthBalance = operatorDelegators[i].getStakedETHBalance();

           // Save it to the array for the OD
           operatorValues[operatorValues.length - 1] = operatorEthBalance;

           // Add it to the total TVL for this OD
           operatorTVL += operatorEthBalance;

           // Add it to the total TVL for the protocol
@>          totalTVL += operatorTVL;

           // Save the TVL for this OD
           operatorDelegatorTVLs[i] = operatorTVL;

           // Set withdrawQueueTokenBalanceRecorded flag to true
           withdrawQueueTokenBalanceRecorded = true;

           unchecked {
               ++i;
           }
       }

       // Get the value of native ETH held in the deposit queue and add it to the total TVL
@>      totalTVL += address(depositQueue).balance;

       // Add native ETH help in withdraw Queue and totalWithdrawalQueueValue to totalTVL
@>      totalTVL += (address(withdrawQueue).balance + totalWithdrawalQueueValue);

       return (operatorDelegatorTokenTVLs, operatorDelegatorTVLs, totalTVL);
   }
```

It's important to note that `totalWithdrawalQueueValue` is not the amount queued for withdrawals by users. it's the amount of tokens in the `WithdrawalQueue` contract. That value does not change when users queue for withdrawal, it only changes when they actually claim. We can clearly see that `totalTVL` does not reflect the queued withdrawals by users. Therefore when users are minted `ezETH`, an incorrect `totalTVL` will be used, and they will be minted an incorrect amount.

**To summarize**: When users withdraw, their withdrawal is queued until `coolDownPeriod` has passed. The queued withdrawals are not accounted for when we calculate `totalTVL` and users who continue to deposit will be minted an incorrect amount of `ezETH`.

## Tools Used
Manual Review.

## Recommended Mitigation Steps
When calculating `totalTVL`, subtract the amount that is queued for withdrawals by users.

## [M-1] `deposit` and `withdraw` should have slippage protection

## Impact
Both `depositing` and `withdrawing` calculate the `totalTVL` that is used to determine how much `ezETH` to mint and how many tokens to send to the caller.

The problem is that the `tvl` can change prior to the execution of `deposit` and `withdraw` functions (while it's in the mempool). Users may not receive the expected amount of tokens.

## Proof of Concept
Users deposit via `RestakeManager::deposit`
https://github.com/code-423n4/2024-04-renzo/blob/main/contracts/RestakeManager.sol#L491
```javascript
   function deposit(
       IERC20 _collateralToken,
       uint256 _amount,
       uint256 _referralId
   ) public nonReentrant notPaused {
       // Verify collateral token is in the list - call will revert if not found
       uint256 tokenIndex = getCollateralTokenIndex(_collateralToken);

       // Get the TVLs for each operator delegator and the total TVL
       (
           uint256[][] memory operatorDelegatorTokenTVLs,
           uint256[] memory operatorDelegatorTVLs,
           uint256 totalTVL
@>      ) = calculateTVLs();

       // Get the value of the collateral token being deposited
       uint256 collateralTokenValue = renzoOracle.lookupTokenValue(_collateralToken, _amount);

       // Enforce TVL limit if set, 0 means the check is not enabled
       if (maxDepositTVL != 0 && totalTVL + collateralTokenValue > maxDepositTVL) {
           revert MaxTVLReached();
       }

       // Enforce individual token TVL limit if set, 0 means the check is not enabled
       if (collateralTokenTvlLimits[_collateralToken] != 0) {
           // Track the current token's TVL
           uint256 currentTokenTVL = 0;

           // For each OD, add up the token TVLs
           uint256 odLength = operatorDelegatorTokenTVLs.length;
           for (uint256 i = 0; i < odLength; ) {
               currentTokenTVL += operatorDelegatorTokenTVLs[i][tokenIndex];
               unchecked {
                   ++i;
               }
           }

           // Check if it is over the limit
           if (currentTokenTVL + collateralTokenValue > collateralTokenTvlLimits[_collateralToken])
               revert MaxTokenTVLReached();
       }

       // Determine which operator delegator to use
       IOperatorDelegator operatorDelegator = chooseOperatorDelegatorForDeposit(
           operatorDelegatorTVLs,
           totalTVL
       );

       .
       .
       .

       // Calculate how much ezETH to mint
@>      uint256 ezETHToMint = renzoOracle.calculateMintAmount(
           totalTVL,
           collateralTokenValue,
           ezETH.totalSupply()
       );

       // Mint the ezETH
       ezETH.mint(msg.sender, ezETHToMint);

       // Emit the deposit event
       emit Deposit(msg.sender, _collateralToken, _amount, ezETHToMint, _referralId);
   }
```

The values returned by `calculateTVLs()` determines how much `ezETH` to mint to the user.

When users withdraw, they can call `WithdrawQueue::withdraw`
https://github.com/code-423n4/2024-04-renzo/blob/main/contracts/Withdraw/WithdrawQueue.sol#L206
```javascript
   function withdraw(uint256 _amount, address _assetOut) external nonReentrant {
       // check for 0 values
       if (_amount == 0 || _assetOut == address(0)) revert InvalidZeroInput();

       // check if provided assetOut is supported
       if (withdrawalBufferTarget[_assetOut] == 0) revert UnsupportedWithdrawAsset();

       // transfer ezETH tokens to this address
       IERC20(address(ezETH)).safeTransferFrom(msg.sender, address(this), _amount);

       // calculate totalTVL
@>      (, , uint256 totalTVL) = restakeManager.calculateTVLs();

       // Calculate amount to Redeem in ETH
       uint256 amountToRedeem = renzoOracle.calculateRedeemAmount(
           _amount,
           ezETH.totalSupply(),
@>          totalTVL
       );

       // update amount in claim asset, if claim asset is not ETH
       if (_assetOut != IS_NATIVE) {
           // Get ERC20 asset equivalent amount
           amountToRedeem = renzoOracle.lookupTokenAmountFromValue(
               IERC20(_assetOut),
               amountToRedeem
           );
       }

       // revert if amount to redeem is greater than withdrawBufferTarget
       if (amountToRedeem > getAvailableToWithdraw(_assetOut)) revert NotEnoughWithdrawBuffer();

       // increment the withdrawRequestNonce
       withdrawRequestNonce++;

       // add withdraw request for msg.sender
       withdrawRequests[msg.sender].push(
           WithdrawRequest(
               _assetOut,
               withdrawRequestNonce,
               amountToRedeem,
               _amount,
               block.timestamp
           )
       );

       // add redeem amount to claimReserve of claim asset
       claimReserve[_assetOut] += amountToRedeem;

       emit WithdrawRequestCreated(
           withdrawRequestNonce,
           msg.sender,
           _assetOut,
           amountToRedeem,
           _amount,
           withdrawRequests[msg.sender].length - 1
       );
   }
```

`totalTVL` returned from `calculateTVLs()` determines the `amountToRedeem`.

Let's take a look at `RestakeManager::calculateTVLs`:
https://github.com/code-423n4/2024-04-renzo/blob/main/contracts/RestakeManager.sol#L274
```javascript
function calculateTVLs() public view returns (uint256[][] memory, uint256[] memory, uint256) {
       uint256[][] memory operatorDelegatorTokenTVLs = new uint256[][](operatorDelegators.length);
       uint256[] memory operatorDelegatorTVLs = new uint256[](operatorDelegators.length);
       uint256 totalTVL = 0;

       // Iterate through the ODs
       uint256 odLength = operatorDelegators.length;

       // flag for withdrawal queue balance set
       bool withdrawQueueTokenBalanceRecorded = false;
       address withdrawQueue = address(depositQueue.withdrawQueue());

       // withdrawalQueue total value
       uint256 totalWithdrawalQueueValue = 0;

       for (uint256 i = 0; i < odLength; ) {
           // Track the TVL for this OD
           uint256 operatorTVL = 0;

           // Track the individual token TVLs for this OD - native ETH will be last item in the array
           uint256[] memory operatorValues = new uint256[](collateralTokens.length + 1);
           operatorDelegatorTokenTVLs[i] = operatorValues;

           // Iterate through the tokens and get the value of each
           uint256 tokenLength = collateralTokens.length;
           for (uint256 j = 0; j < tokenLength; ) {
               // Get the value of this token

               uint256 operatorBalance = operatorDelegators[i].getTokenBalanceFromStrategy(
                   collateralTokens[j]
               );

               // Set the value in the array for this OD
               operatorValues[j] = renzoOracle.lookupTokenValue(
                   collateralTokens[j],
                   operatorBalance
               );

               // Add it to the total TVL for this OD
               operatorTVL += operatorValues[j];

               // record token value of withdraw queue
               if (!withdrawQueueTokenBalanceRecorded) {
                   totalWithdrawalQueueValue += renzoOracle.lookupTokenValue(
                       collateralTokens[i],
                       collateralTokens[j].balanceOf(withdrawQueue)
                   );
               }

               unchecked {
                   ++j;
               }
           }

           // Get the value of native ETH staked for the OD
           uint256 operatorEthBalance = operatorDelegators[i].getStakedETHBalance();

           // Save it to the array for the OD
           operatorValues[operatorValues.length - 1] = operatorEthBalance;

           // Add it to the total TVL for this OD
           operatorTVL += operatorEthBalance;

           // Add it to the total TVL for the protocol
           totalTVL += operatorTVL;

           // Save the TVL for this OD
           operatorDelegatorTVLs[i] = operatorTVL;

           // Set withdrawQueueTokenBalanceRecorded flag to true
           withdrawQueueTokenBalanceRecorded = true;

           unchecked {
               ++i;
           }
       }

       // Get the value of native ETH held in the deposit queue and add it to the total TVL
       totalTVL += address(depositQueue).balance;

       // Add native ETH help in withdraw Queue and totalWithdrawalQueueValue to totalTVL
       totalTVL += (address(withdrawQueue).balance + totalWithdrawalQueueValue);

       return (operatorDelegatorTokenTVLs, operatorDelegatorTVLs, totalTVL);
   }
```

As you can see, `totalTVL` is determined by factors such as the balance of `depositQueue`, `withdrawQueue`, etc. These values can change while the user's `deposit` and `withdraw` calls are in the mempool.

They may not receive the expected amount of tokens that they should receive when they called these functions.

## Tools Used
Manual Review.

## Recommended Mitigation Steps
Add slippage protection to user `deposit` and `withdraw` functions.
