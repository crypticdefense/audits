# Opal

[Opal](https://cantina.xyz/code/28425672-ce54-4c66-b188-c4d5650d6790/overview) is a protocol built on Ethereum, aiming to enhance Dexs' liquidity flywheel, starting with the Balancer ecosystem.

## Audit Findings Summary

| ID | Title | Severity |
|-----------|----------|----------|
| [H-1](#h-1-omnipoolcontrollerlastweightupdate-is-never-updatedpopulated) | OmnipoolController::lastWeightUpdate is never updated/populated | High |
| [H-2](#h-2-bptoraclebptpriceweightpool-incorrectly-assumes-that-totalsupply-works-for-all-pools) | BPTOracle::BptPriceWeightPool incorrectly assumes that totalSupply() works for all pools | High |
| [M-1](#m-1-gaugefactorydeploygauge-function-does-not-check-if-a-liquidity-gauge-for-an-lptoken-already-exists) | GaugeFactory::deployGauge() does not check if a liquidity gauge for an lpToken already exists | Medium |
| [I-1](#i-1-omnipool_withdrawfromaurapool-exits-pool-without-slippage-protection) | Omnipool::_withdrawFromAuraPool exits pool without slippage protection | Informational |
-----

## [H-1] `OmnipoolController::lastWeightUpdate` is never updated/populated

The `OmnipoolController.sol` contract contains a mapping `mapping(address => uint256) public lastWeightUpdate;` that maps the address of a pool to the last weight that was updated. However, this mapping is never updated/populated, making the `getLastWeightUpdate` function redundant.

`OmnipoolController::lastWeightUpdate` (#L329-331)

```javascript
function getLastWeightUpdate(address pool) external view returns (uint256) {
        return lastWeightUpdate[pool];
    }
```

## [H-2] `BPTOracle::BptPriceWeightPool` incorrectly assumes that `totalSupply()` works for all pools

Description: The `BptPriceWeightPool` function calculates the total supply of BPT tokens for a pool using `totalSupply()`.

BPTOracle.sol#L163
```javascript
function BptPriceWeightPool(bytes32 poolId) public view returns (uint256) {
        (address[] memory tokens,,) = balancerVault.getPoolTokens(poolId);

        (address poolAddress,) = balancerVault.getPool(poolId);

        // 1. weight = balance * price / invariant
        uint256[] memory weights = IManagedPool(poolAddress).getNormalizedWeights();

        uint256 length = tokens.length;

        int256 invariant = int256(IBalancerPool(poolAddress).getInvariant());

        int256 totalPi = PRBMathSD59x18.fromInt(1e18);

        for (uint256 i = 0; i < length;) {
            // Get token price
            uint256 assetPrice = getUSDPrice(address(tokens[i]));

            uint256 weight = weights[i];

            int256 actualPrice = int256(assetPrice.mul(1e18).div(weight));

            int256 uniquePi = actualPrice.pow(int256(weight));

            totalPi = totalPi.mul(uniquePi);

            unchecked {
                ++i;
            }
        }

        // Pool TVL in USD
        int256 numerator = totalPi.mul(invariant);

        // 4. Total Supply of BPT tokens for this pool
@>      int256 totalSupply = int256(IBalancerPool(poolAddress).totalSupply());

        // 5. BPT Price (USD) = TVL / totalSupply
        uint256 bptPrice = uint256((numerator.toInt().div(totalSupply)));
        return bptPrice;
    }
```

However, it is specified in the Balancer docs that totalSupply only works for old legacy pools since they do not have pre-minted BPT. Newer pools have pre-minted BPT and should use getActualSupply to calculate the total supply of the pool.

Recommendation: Check if the pool is older or newer. If older, use totalSupply, otherwise use getActualSupply to calculate the total supply of the pool.

## [M-1] GaugeFactory::deployGauge() function does not check if a liquidity gauge for an lpToken already exists

Description: The `GaugeFactory.sol` contract contains a function deployGauge() that deploys a new liquidity gauge, given the address of the lpToken. However, it does not check if the gauge has already been deployed, so users can create duplicate gauges for the same lpToken address.

`GaugeFactory::deployGauge()` (#L57-71)
```javascript
/**
     * @notice  Deploy new liquidity gauge
     * @param   lpToken  address of the lpToken
     * @return  address  address of the new liquidity gauge
     */
    function deployGauge(address lpToken) external returns (address) {
        if (lpToken == address(0)) revert AddressZero();

        address gauge = Clones.clone(implementation);
        ILiquidityGauge(gauge).initialize(lpToken);

        isFactoryGauge[gauge] = true;

        gaugeToLpToken[gauge] = lpToken;
        lpTokenToGauge[lpToken] = gauge;

        emit NewGauge(lpToken, gauge);

        return gauge;
    }
```

Recommendation: Consider checking if a liquidity gauge for an lpToken already has been deployed.

## [I-1] `Omnipool::_withdrawFromAuraPool` exits pool without slippage protection

```javascript
Description: When exiting the balance pool, exitPool is called with an empty array for minAmountsOut which causes the position to be exited with no slippage protection.

Omnipool.sol#L533-570

/**
     * @notice Withdraw Balancer Pool Tokens (BPT) from a given pool
     * @param _pool The underlying pool information
     * @param _underlyingAmount The amount of2 BPT to withdraw
     */
    function _withdrawFromAuraPool(UnderlyingPool memory _pool, uint256 _underlyingAmount)
        internal
    {
        IBalancerPool auraPool = IBalancerPool(_pool.poolAddress);

        // Compute how much BPT we need to withdraw
        uint256 _bptPrice = bptOracle.getPoolValuation(_pool.poolId, _pool.poolType);
        uint256 _bptAmountOut = _underlyingAmount.mulDown(
            bptOracle.getUSDPrice(address(underlyingToken))
        ).divDown(_bptPrice).convertScale(underlyingToken.decimals(), 18);

        // Make sure we have enough BPT to withdraw
        uint256 balance = auraPool.balanceOf(address(this));
        require(balance >= _bptAmountOut, "not enough balance");
        auraPool.withdrawAndUnwrap(_bptAmountOut, true);

        uint256 assetIndex = _pool.assetIndex;

        // BPT not being in the assets array, we need to adjust the index
        if (_pool.bptIndex > 0 && _pool.bptIndex < assetIndex) {
            assetIndex = assetIndex - 1;
        }
        bytes memory userData = abi.encode(
            IBalancerVault.ExitKind.EXACT_BPT_IN_FOR_ONE_TOKEN_OUT, _bptAmountOut, assetIndex
        );
        IBalancerVault.ExitPoolRequest memory exitRequest = IBalancerVault.ExitPoolRequest({
            assets: _pool.assets,

            minAmountsOut: new uint256[](_pool.assets.length),
            userData: userData,
            toInternalBalance: false
        });
```

As you can see, minAmountsOut is set to new uint256[](_pool.assets.length). This means that it is always an empty array can lead to sandwich attacks due to no slippage protection.

Recommendation: Allow for the ability to specify the amount of minAmountsOut.
