# LoopFi

[A dedicated lending market](https://code4rena.com/audits/2024-07-loopfi) for Ethereum carry trades. Users can supply a long tail of Liquid Restaking Tokens (LRT) and their derivatives as collateral to borrow ETH for increased yield exposure.

## Audit Findings Summary

| ID | Title | Severity |
|----|----------|----------|
| [H-1](#h-1-auravaultclaim-reward-calculation-does-not-deduct-fees-from-reward-amount-causing-dos-or-extra-rewards-lost) | `AuraVault::claim` reward calculation does not deduct fees from reward amount, causing DoS or extra rewards lost | High |
| [H-2](#h-2-liquidation-doesnt-account-for-penalty-when-calculating-collateral-to-give-allowing-users-to-profit-by-borrowing-and-self-liquidating) | Liquidation doesn't account for penalty when calculating collateral to give, allowing users to profit by borrowing and self-liquidating | High |
| [H-3](#h-3-poolv3repaycreditaccount-doesnt-take-into-account-the-profit-when-updating-the-expected-liquidity-causing-incorrect-accounting) | `PoolV3::repayCreditAccount` doesn't take into account the `profit` when updating the `expected liquidity`, causing incorrect accounting | High |
| [M-1](#m-1-auravault-reward-calculation-can-be-incorrect-due-to-insufficient-chainlink-latestrounddata-check) | `AuraVault` reward calculation can be incorrect due to insufficient Chainlink `latestRoundData()` check | Medium |
| [M-2](#m-2-auravault-lacks-slippage-protection-for-deposit-mint-withdraw-redeem) | `AuraVault` lacks slippage protection for deposit, mint, withdraw, redeem | Medium |
| [M-3](#m-3-cdpvaultliquidatepositionbaddebt-incorrectly-calculates-the-debt-loss-causing-incorrect-accounting-within-poolv3-and-more-treasury-shares-to-burn) | `CDPVault::liquidatePositionBadDebt` incorrectly calculates the `debt loss`, causing incorrect accounting within `PoolV3` and more treasury shares to burn | Medium |
---

# [H-1] `AuraVault::claim` reward calculation does not deduct fees from reward amount, causing DoS or extra rewards lost

# Vulnerability details

## Impact

`AuraVault::claim` allows users to claim rewards corresponding to the amount of `WETH` they are depositing in the same call.

Prior to sending rewards to `msg.sender`, a percentage of the rewards is sent to the `vault locker rewards`. However, the percentage of the rewards sent to the `vault locker rewards` is not deducted from the amount that is sent to the caller. The entire `reward amount` is sent to `msg.sender`.

This is problematic, as it creates two possible scenarios:

1. Contract attempts to send more reward tokens than it holds, causing DoS
2. Contract successfully sends extra reward tokens, essentially stealing rewards from others

Therefore, the impact ranges from `stolen funds` to `Denial of Service`.

## Proof of Concept

As users interact with the `AuraVault` contract, the contract will accumulate rewards through interaction with an external [rewards contract](https://etherscan.io/address/0x2a14db8d09db0542f6a371c0cb308a768227d67d#code), which acts as an ERC-4626 vault.

Users can deposit, withdraw, redeem, and *claim* rewards:

[AuraVault.sol#L275-L310](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/vendor/AuraVault.sol#L275-L310)
```javascript
/**
 * @notice Allows anyone to claim accumulated rewards by depositing WETH instead
 * @param amounts An array of reward amounts to be claimed ordered as [rewardToken, secondaryRewardToken]
 * @param maxAmountIn The max amount of WETH to be sent to the Vault
 */
function claim(uint256[] memory amounts, uint256 maxAmountIn) external returns (uint256 amountIn) {
    // Claim rewards from Aura reward pool
    IPool(rewardPool).getReward();

    // Compute assets amount to be sent to the Vault
    VaultConfig memory _config = vaultConfig;
    amountIn = _previewReward(amounts[0], amounts[1], _config);

    // Transfer assets to Vault
    require(amountIn <= maxAmountIn, "!Slippage");
    IERC20(asset()).safeTransferFrom(msg.sender, address(this), amountIn);

    // Compound assets into "asset" balance
    IERC20(asset()).safeApprove(rewardPool, amountIn);
    IPool(rewardPool).deposit(amountIn, address(this));

    // Distribute BAL rewards
@>      IERC20(BAL).safeTransfer(_config.lockerRewards, (amounts[0] * _config.lockerIncentive) / INCENTIVE_BASIS);
@>      IERC20(BAL).safeTransfer(msg.sender, amounts[0]);

    // Distribute AURA rewards
    if (block.timestamp <= INFLATION_PROTECTION_TIME) {
@>          IERC20(AURA).safeTransfer(_config.lockerRewards, (amounts[1] * _config.lockerIncentive) / INCENTIVE_BASIS);
@>          IERC20(AURA).safeTransfer(msg.sender, amounts[1]);
    } else {
        // after INFLATION_PROTECTION_TIME
        IERC20(AURA).safeTransfer(_config.lockerRewards, IERC20(AURA).balanceOf(address(this)));
    }

    emit Claimed(msg.sender, amounts[0], amounts[1], amountIn);
}
```

Firstly, rewards are claimed from the `Aura reward pool`, proceeded by a call to `_previewReward()` to calculate the amount of `WETH` the caller must deposit to receive the amount of rewards they have specified.

The issue is with the transferring of rewards. We can see the `vault locker rewards` receives a percentage of the rewards, calculated by `(amounts[0] * _config.lockerIncentive) / INCENTIVE_BASIS)`.

However, the entire amount of rewards is still sent to the caller, without accounting for the percentage that was just sent to the `vault locker rewards`. Therefore, this call is sending extra rewards to the caller.

As mentioned, this leads to two scenarios:

1. DoS due to insufficient rewards
2. Extra rewards successfully sent to the caller, essentially stealing rewards from others

Consider the following scenario:

1. Alice decides to deposit `WETH` and claim `BAL` and `AURA` rewards via a call to `AuraVault::claim`. `_config.lockerIncentive` is set to 1000 and `INCENTIVE_BASIS` is set to 10000, effectively setting the fee portion to 10%.
2. Alice sets `amounts[0] = 100e18 BAL` and `amount[1] = 100e18 AURA`.
3. `IPool(rewardPool).getReward();` is called, setting the rewards held in the `AuraVault` contract to `100e18 BAL` and `100e18 AURA`.
4. `IERC20(BAL).safeTransfer(_config.lockerRewards, (amounts[0] * _config.lockerIncentive) / INCENTIVE_BASIS);` call sends `100e18 * 1000 / 10000 = 10e18` `BAL` tokens to `_config.lockerRewards`, which is the `vault locker rewards`.
5. The `AuraVault` contract now holds `90e18 BAL` and `100e18 AURA`.
6. `IERC20(BAL).safeTransfer(msg.sender, amounts[0]);` attempts to send `100e18 BAL` to `msg.sender`, however `10e18` was already sent to `locker rewards`, so this call will DoS due to insufficient funds.

The call will revert in the case described above, and Alice would have to specify a lower amount of rewards (i.e, 50e18 BAL and AURA), but we can see that the contract will still send more rewards than intended, effectively stealing rewards from others.

## Tools Used

Manual review, foundry

## Recommended Mitigation Steps

Ensure the amount sent to the locker is deducted from the amount sent to the caller:

```diff
/**
 * @notice Allows anyone to claim accumulated rewards by depositing WETH instead
 * @param amounts An array of reward amounts to be claimed ordered as [rewardToken, secondaryRewardToken]
 * @param maxAmountIn The max amount of WETH to be sent to the Vault
 */
function claim(uint256[] memory amounts, uint256 maxAmountIn) external returns (uint256 amountIn) {
    // Claim rewards from Aura reward pool
    IPool(rewardPool).getReward();

    // Compute assets amount to be sent to the Vault
    VaultConfig memory _config = vaultConfig;
    amountIn = _previewReward(amounts[0], amounts[1], _config);

    // Transfer assets to Vault
    require(amountIn <= maxAmountIn, "!Slippage");
    IERC20(asset()).safeTransferFrom(msg.sender, address(this), amountIn);

    // Compound assets into "asset" balance
    IERC20(asset()).safeApprove(rewardPool, amountIn);
    IPool(rewardPool).deposit(amountIn, address(this));

    // Distribute BAL rewards
+       uint256 fee = (amounts[0] * _config.lockerIncentive) / INCENTIVE_BASIS;
+       uint256 amount = amounts[0] - fee;
-       IERC20(BAL).safeTransfer(_config.lockerRewards, (amounts[0] * _config.lockerIncentive) / INCENTIVE_BASIS);
-       IERC20(BAL).safeTransfer(msg.sender, amounts[0]);
+       IERC20(BAL).safeTransfer(_config.lockerRewards, fee);
+       IERC20(BAL).safeTransfer(msg.sender, amount);

    // Distribute AURA rewards
    if (block.timestamp <= INFLATION_PROTECTION_TIME) {
+           fee = (amounts[1] * _config.lockerIncentive) / INCENTIVE_BASIS;
+           amount = amounts[1] - fee;
-           IERC20(AURA).safeTransfer(_config.lockerRewards, (amounts[1] * _config.lockerIncentive) / INCENTIVE_BASIS);
-           IERC20(AURA).safeTransfer(msg.sender, amounts[1]);
+           IERC20(BAL).safeTransfer(_config.lockerRewards, fee);
+           IERC20(BAL).safeTransfer(msg.sender, amount);
    } else {
        // after INFLATION_PROTECTION_TIME
        IERC20(AURA).safeTransfer(_config.lockerRewards, IERC20(AURA).balanceOf(address(this)));
    }

    emit Claimed(msg.sender, amounts[0], amounts[1], amountIn);
}
```

# [H-2] Liquidation doesn't account for penalty when calculating collateral to give, allowing users to profit by borrowing and self-liquidating

# Vulnerability details

## Impact

`CDPVault` allows users to borrow `underlying` from `PoolV3` by depositing collateral into the vault, such that the `(collateral value of their position / liquidationRatio) >= their current total debt`.

Users must repay their debt fully via `CDPVault::repay`, and the amount must cover their entire `current total debt`, which also includes various interest factors. If the value of their collateral divided by liquidatioRatio is less than the debt of their position, then their position is considered `unsafe` and anyone can `liquidate` the position by buying the collateral at a `discount`. The amount spent by the caller is used to cover for the debt.

To ensure that users cannot profit from self liquidations, the `liquidatePosition` function incorporates a penalty mechanism, that is intended to deduct fees from the payment amount, which subsequently goes to the protocol as profit.

The problem is that when the `liquidatePosition` function calculates the collateral to give to the caller, it utilizes the the repay amount *without* the penalty, essentially functioning as if there is no penalty mechanism at all. The caller can specify any `repay amount`, and the collateral they receive will correspond directly to `repay amount / discount`, with no penalty.

This allows malicious users to profit by `deposit collateral -> borrow WETH -> have their position become unsafe -> buy collateral with WETH at a discount`. Malicious users can profit and steal funds from lenders and the protocol.

> The natspec for the `CDPVault::liquidatePosition` states that "From that repay amount a penalty (`liquidationPenalty`) is subtracted to mitigate against profitable self liquidations." However, we will see in the PoC how this has no impact against profitable self liquidations

## Proof of Concept

The following block is executed when users repay their debt:

[CDPVault.sol#L402-L426](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/CDPVault.sol#L402-L426)
```javascript
  } else if (deltaDebt < 0) {
@>      uint256 maxRepayment = calcTotalDebt(debtData);
      uint256 amount = abs(deltaDebt);
      if (amount >= maxRepayment) {
          amount = maxRepayment; // U:[CM-11]
          deltaDebt = -toInt256(maxRepayment);
      }

      poolUnderlying.safeTransferFrom(creditor, address(pool), amount);

      uint128 newCumulativeQuotaInterest;
      if (amount == maxRepayment) {
          newDebt = 0;
          newCumulativeIndex = debtData.cumulativeIndexNow;
          profit = debtData.accruedInterest;
          newCumulativeQuotaInterest = 0;
      } else {
          (newDebt, newCumulativeIndex, profit, newCumulativeQuotaInterest) = calcDecrease(
              amount, // delta debt
              position.debt,
              debtData.cumulativeIndexNow, // current cumulative base interest index in Ray
              position.cumulativeIndexLastUpdate,
              debtData.cumulativeQuotaInterest
          );
      }
```

For users to completely repay their loan, they must pay `maxRepayment` amount, which is calculated via a call to `calcTotalDebt`.

If the position is unsafe (collateral value / liquidation ratio < total debt), then anyone can liquidate it for a discount:

[CDPVault.sol#L521-L532](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/CDPVault.sol#L521-L532)
```javascript
      // load price and calculate discounted price
      uint256 spotPrice_ = spotPrice();
@>      uint256 discountedPrice = wmul(spotPrice_, liqConfig_.liquidationDiscount);
      if (spotPrice_ == 0) revert CDPVault__liquidatePosition_invalidSpotPrice();
      // Enusure that there's no bad debt
      if (calcTotalDebt(debtData) > wmul(position.collateral, spotPrice_)) revert CDPVault__BadDebt();

      // compute collateral to take, debt to repay and penalty to pay
@>      uint256 takeCollateral = wdiv(repayAmount, discountedPrice);
      uint256 deltaDebt = wmul(repayAmount, liqConfig_.liquidationPenalty);
      uint256 penalty = wmul(repayAmount, WAD - liqConfig_.liquidationPenalty);
```

There is also a penalty that the liquidator must pay (deducted from `repayAmount`). This is to mitigate profits from self-liquidation, as stated by the natspec of this function:

[CDPVault.sol#L503-L504](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/CDPVault.sol#L503-L504)
```javascript
  /// ... From that repay amount a penalty (`liquidationPenalty`) is subtracted to mitigate against
  /// profitable self liquidations ...
```

So the actual amount of debt repaid by the liquidator is `repayAmount - penalty`:

[CDPVault.sol#L538-L539](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/CDPVault.sol#L538-L539)
```javascript
  // transfer the repay amount from the liquidator to the vault
  poolUnderlying.safeTransferFrom(msg.sender, address(pool), repayAmount - penalty);
```

In the same call, the `penalty` is also transferred to the pool, taken as a profit for the protocol.

[CDPVault.sol#L567-L569](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/CDPVault.sol#L567-L569)
```javascript
   // Mint the penalty from the vault to the treasury
      poolUnderlying.safeTransferFrom(msg.sender, address(pool), penalty);
      IPoolV3Loop(address(pool)).mintProfit(penalty);
```

However, there is a critical problem here. We can see that the intention here is that the caller pays `repayAmount - penalty` for the debt, and that the penalty goes towards profit.

This can be confirmed by observing the amount of debt that is covered via repayment:

[CDPVault.sol#L530](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/CDPVault.sol#L530)
```javascript
   uint256 deltaDebt = wmul(repayAmount, liqConfig_.liquidationPenalty);
```

Note that `repayAmount * liqConfig_.liquidationPenalty` is equivalent to `repayAmount - penalty`. So the debt reduced is repayAmount - penalty.

The problem is that the *collateral sent to the caller does not incorporate the penalty for liquidation*.

Essentially, this makes the `penalty` redudant, because the caller still receives the full `repayAmount` of collateral specified, including a `discount`.

A malicious user can perform the following attack scenario:

1. Deposit collateral via `CDPVault::deposit`
2. Borrow WETH via `CDPVault::borrow`
3. Have their position become unsafe (i.e., wait until enough debt interest is accrued such that `(collateral value of their position / liquidationRatio) < their current total debt`)
4. Fully buy back collateral at a discount

### Coded PoC

Note: The value of the discount and penalty were chosen by observing the values currently set in `scripts/config.js`, they were not chosen arbitrarily.

Add the following to `test/unit/CDPVault.t.sol` and run `forge test --mt testSelfLiquidateProfit -vv`

```javascript
  function testSelfLiquidateProfit() public {
      mockWETH.mint(address(this), 20e18);

      // discount = 0.98 ether (0.02% discount)
      // penalty = 0.99 ether (0.01% penalty)
      CDPVault vault = createCDPVault(token, 150 ether, 0, 1.25 ether, 0.99 ether, 0.98 ether);
      createGaugeAndSetGauge(address(vault));

      // create position
      uint256 wethBefore = mockWETH.balanceOf(address(this));
      _modifyCollateralAndDebt(vault, 100 ether, 80 ether);
      uint256 wethBorrowed = mockWETH.balanceOf(address(this)) - wethBefore;
      uint256 collateralDeposited = 100 ether;
      console.log("weth borrowed: ", wethBorrowed);
      console.log("collateral deposited: ", collateralDeposited);

      address position = address(this);
      uint256 amountUserMustRepay = vault.virtualDebt(position);
      console.log("Amount of debt user must repay: ", amountUserMustRepay);

      // any attempt to liquidate now will revert because position is safe
      vm.expectRevert(bytes4(keccak256("CDPVault__liquidatePosition_notUnsafe()")));
      vault.liquidatePosition(position, 1 ether);

      // user waits some time for price to change so position becomes unsafe (but no bad debt yet)
      // in reality, interest will accrue, however to make this PoC simple we will update spot price (which is another way user can take advantage)
      _updateSpot(0.80 ether);
      (uint256 collateral, uint256 debt , , , , ) = vault.positions(position);

      // calculate amount to repay to fully liquidate position.
      uint256 spotAmt = oracle.spot(address(token));
      uint256 discountPercent = 0.98 ether;
      uint256 discountAmount = wmul(spotAmt, discountPercent);
      uint256 repayFull = wmul(collateral, discountAmount);
      console.log("Amount user is repaying: ", repayFull);
      mockWETH.approve(address(vault), repayFull);

      // fully liquidate position
      wethBefore = mockWETH.balanceOf(address(this));
      uint collateralBefore = token.balanceOf(address(this));
      vault.liquidatePosition(position, repayFull);
      uint256 wethSpent = wethBefore - mockWETH.balanceOf(address(this));
      uint256 collateralReceived = token.balanceOf(address(this)) - collateralBefore;
      console.log("weth spent: ", wethSpent);
      console.log("collateral received: ", collateralReceived);

      console.log("Total WETH earned: ", wethBorrowed - wethSpent);
      console.log("collateral lost: ", collateralDeposited -  collateralReceived);

      // confirm that collateral in position is 0
      (collateral, debt, , , , ) = vault.positions(position);
      console.log("collateral remaining in position: ", collateral);
  }
```

```text
[PASS] testSelfLiquidateProfit() (gas: 3761322)
Logs:
weth borrowed:  80000000000000000000
collateral deposited:  100000000000000000000
Amount of debt user must repay:  80000000000000000000
Amount user is repaying:  78400000000000000000
weth spent:  78400000000000000000
collateral received:  100000000000000000000
Total WETH earned:  1600000000000000000
collateral lost:  0
collateral remaining in position:  0

Test result: ok. 1 passed; 0 failed; 0 skipped; finished in 5.46ms

Ran 1 test suites: 1 tests passed, 0 failed, 0 skipped (1 total tests)
```

As displayed in the coded PoC, since the user receives the full amount of collateral without the penalty applied to the amount they receive, the user profits 1.6e18 WETH with the attack scenario described above.

## Tools Used

Manual review, foundry

## Recommended Mitigation Steps

Apply the penalty to `repayAmount` when calculating the amount of collateral to give to the caller. In addition, ensure that the protocol applies a high enough penalty such that self-liquidators cannot profit from this attack.

```diff
  function liquidatePosition(address owner, uint256 repayAmount) external whenNotPaused {
      // validate params
      if (owner == address(0) || repayAmount == 0) revert CDPVault__liquidatePosition_invalidParameters();

      // load configs
      VaultConfig memory config = vaultConfig;
      LiquidationConfig memory liqConfig_ = liquidationConfig;

      // load liquidated position
      Position memory position = positions[owner];
      DebtData memory debtData = _calcDebt(position);

      // load price and calculate discounted price
      uint256 spotPrice_ = spotPrice();
      uint256 discountedPrice = wmul(spotPrice_, liqConfig_.liquidationDiscount);
      if (spotPrice_ == 0) revert CDPVault__liquidatePosition_invalidSpotPrice();
      // Enusure that there's no bad debt
      if (calcTotalDebt(debtData) > wmul(position.collateral, spotPrice_)) revert CDPVault__BadDebt();

      // compute collateral to take, debt to repay and penalty to pay
-       uint256 takeCollateral = wdiv(repayAmount, discountedPrice);
      uint256 deltaDebt = wmul(repayAmount, liqConfig_.liquidationPenalty);
      uint256 penalty = wmul(repayAmount, WAD - liqConfig_.liquidationPenalty);
+       uint256 takeCollateral = wdiv(repayAmount - penalty, discountedPrice);
      if (takeCollateral > position.collateral) revert CDPVault__tooHighRepayAmount();

      // verify that the position is indeed unsafe
      if (_isCollateralized(calcTotalDebt(debtData), wmul(position.collateral, spotPrice_), config.liquidationRatio))
          revert CDPVault__liquidatePosition_notUnsafe();

      // transfer the repay amount from the liquidator to the vault
      poolUnderlying.safeTransferFrom(msg.sender, address(pool), repayAmount - penalty);

      uint256 newDebt;
      uint256 profit;
      uint256 maxRepayment = calcTotalDebt(debtData);
      uint256 newCumulativeIndex;
      if (deltaDebt == maxRepayment) {
          newDebt = 0;
          newCumulativeIndex = debtData.cumulativeIndexNow;
          profit = debtData.accruedInterest;
          position.cumulativeQuotaInterest = 0;
      } else {
          (newDebt, newCumulativeIndex, profit, position.cumulativeQuotaInterest) = calcDecrease(
              deltaDebt, // delta debt
              debtData.debt,
              debtData.cumulativeIndexNow, // current cumulative base interest index in Ray
              debtData.cumulativeIndexLastUpdate,
              debtData.cumulativeQuotaInterest
          );
      }
      position.cumulativeQuotaIndexLU = debtData.cumulativeQuotaIndexNow;
      // update liquidated position
      position = _modifyPosition(owner, position, newDebt, newCumulativeIndex, -toInt256(takeCollateral), totalDebt);

      pool.repayCreditAccount(debtData.debt - newDebt, profit, 0); // U:[CM-11]
      // transfer the collateral amount from the vault to the liquidator
      token.safeTransfer(msg.sender, takeCollateral);

      // Mint the penalty from the vault to the treasury
      poolUnderlying.safeTransferFrom(msg.sender, address(pool), penalty);
      IPoolV3Loop(address(pool)).mintProfit(penalty);

      if (debtData.debt - newDebt != 0) {
          IPoolV3(pool).updateQuotaRevenue(_calcQuotaRevenueChange(-int(debtData.debt - newDebt))); // U:[PQK-15]
      }
  }
```

# [H-3] `PoolV3::repayCreditAccount` doesn't take into account the `profit` when updating the `expected liquidity`, causing incorrect accounting

# Vulnerability details

## Impact

`PoolV3::lendCreditAccount` and `PoolV3::repayCreditAccount` are responsible for lending and repaying credit to users, which can only be called by `credit manager roles`, for example `Flashlender`, which is used for flash loans.

The problem is `PoolV3::repayCreditAccount` does not take into account the `profit` from lending the credit, which causes incorrect accounting for the `expected liquidity` when calling `_updateBaseInterest`.

This will impact several core functionalities of the `PoolV3` contract, such as `_baseInterestRate` (used for interest calculations), `totalAssets()`, `supplyRate()`, etc.

Due to a lower `expected liquidity` value than in actuality, in most cases this will be a loss to the protocol and lenders, where borrowers may benefit from lower interest rates.

In addition, `PoolV3` may not be `ERC4626` compliant due to calculations that utilize the `expected liquidity`, which will be incorrect (i.e, `totalAssets()` will not correctly reflect the total assets in the pool).

## Proof of Concept

`PoolV3::repayCreditAccount` is called to repay credit:

[PoolV3.sol#L529-L576](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/PoolV3.sol#L529-L576)
```javascript
  function repayCreditAccount(
      uint256 repaidAmount,
@>      uint256 profit,
@>      uint256 loss
  )
      external
      override
      creditManagerOnly // U:[LP-2C]
      whenNotPaused // U:[LP-2A]
      nonReentrant // U:[LP-2B]
  {
      uint128 repaidAmountU128 = repaidAmount.toUint128();

      DebtParams storage cmDebt = _creditManagerDebt[msg.sender];
      uint128 cmBorrowed = cmDebt.borrowed;
      if (cmBorrowed == 0) {
          revert CallerNotCreditManagerException(); // U:[LP-2C,14A]
      }

      if (profit > 0) {
          _mint(treasury, convertToShares(profit)); // U:[LP-14B]
      } else if (loss > 0) {
          address treasury_ = treasury;
          uint256 sharesInTreasury = balanceOf(treasury_);
          uint256 sharesToBurn = convertToShares(loss);
          if (sharesToBurn > sharesInTreasury) {
              unchecked {
                  emit IncurUncoveredLoss({
                      creditManager: msg.sender,
                      loss: convertToAssets(sharesToBurn - sharesInTreasury)
                  }); // U:[LP-14D]
              }
              sharesToBurn = sharesInTreasury;
          }
          _burn(treasury_, sharesToBurn); // U:[LP-14C,14D]
      }

      _updateBaseInterest({
@>          expectedLiquidityDelta: -loss.toInt256(), //@audit-issue doesn't take into account the profit
          availableLiquidityDelta: 0,
          checkOptimalBorrowing: false
      }); // U:[LP-14B,14C,14D]

      _totalDebt.borrowed -= repaidAmountU128; // U:[LP-14B,14C,14D]
      cmDebt.borrowed = cmBorrowed - repaidAmountU128; // U:[LP-14B,14C,14D]

      emit Repay(msg.sender, repaidAmount, profit, loss); // U:[LP-14B,14C,14D]
  }
```

However, we can see that only the `loss` is taken into account when updating the `expected liquidity`, not the `profit` gained from lending the credit.

This is problematic because `expected liquidity` is supposed to hold the amount of underlying that would be in the pool if debt principal is repaid. It is correctly accounting for the loss, but not the profit gained.

[PoolV3.sol#L642-L668)](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/PoolV3.sol#L642-L668)
```javascript
  function _updateBaseInterest(
      int256 expectedLiquidityDelta,
      int256 availableLiquidityDelta,
      bool checkOptimalBorrowing
  ) internal {
@>      uint256 expectedLiquidity_ = (expectedLiquidity().toInt256() + expectedLiquidityDelta).toUint256();

     ...

@>      _expectedLiquidityLU = expectedLiquidity_.toUint128(); // U:[LP-18]
      _baseInterestRate = ILinearInterestRateModelV3(interestRateModel)
          .calcBorrowRate({
@>              expectedLiquidity: expectedLiquidity_,
              availableLiquidity: availableLiquidity_,
              checkOptimalBorrowing: checkOptimalBorrowing
          })
          .toUint128(); // U:[LP-18]
  }
```

We can see how the accounting for `_expectedLiquidityLU` and `_baseInterestRate` will be incorrect from the `_updateBaseInterest` call. `_baseInterestRate` won't necessarily be impacted on each call due to how `calcBorrowRate()` of the `interestRateModel` is [implemented](https://github.com/Gearbox-protocol/core-v3/blob/main/contracts/pool/LinearInterestRateModelV3.sol#L92). However, we can clearly see that `_expectedLiquidityLU` will be lower than expected, which will impact each function that utilizes `_expectedLiquidityLU`.

Let's take a look at how `flash loans` are implemented:

[Flashlender.sol#L87-L109](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/Flashlender.sol#L87-L109)
```javascript
  function flashLoan(
      IERC3156FlashBorrower receiver,
      address token,
      uint256 amount,
      bytes calldata data
  ) external override nonReentrant returns (bool) {
      if (token != address(underlyingToken)) revert Flash__flashLoan_unsupportedToken();
      uint256 fee = wmul(amount, protocolFee);
      uint256 total = amount + fee;

@>      pool.lendCreditAccount(amount, address(receiver));

      emit FlashLoan(address(receiver), token, amount, fee);

      if (receiver.onFlashLoan(msg.sender, token, amount, fee, data) != CALLBACK_SUCCESS)
          revert Flash__flashLoan_callbackFailed();

      // reverts if not enough Stablecoin have been send back
      underlyingToken.transferFrom(address(receiver), address(pool), total);
@>      pool.repayCreditAccount(total - fee, fee, 0);

      return true;
  }
```

The `profit` received by the pool is the `fee` of the flash loan, and since it is not added to `expected liquidity`, the `expected liquidity` value will continue to be far lower than actuality.

### Coded PoC

The same test will be ran to display the problem and the solution.

Add the line `import {console} from "../../../lib/forge-std/src/console.sol";` to `test/unit/Flashlender.t.sol`

1. Add the following to `test/unit/Flashlender.t.sol` and run `forge test --mt testIncorrectExpectedLiquidity -vv`

```javascript
  function testIncorrectExpectedLiquidity() public {
      uint256 flashLoanAmount = 1e23;
      uint256 maxAvailable = underlyingToken.balanceOf(address(liquidityPool));
      flashlenderFive.flashLoan(immediatePaybackReceiverFive, address(underlyingToken), flashLoanAmount, "");
      uint256 _expectedLiquidityLU = liquidityPool.expectedLiquidityLU();
      uint256 expectedLiquidity = liquidityPool.expectedLiquidity();
      uint256 totalAssets = liquidityPool.totalAssets();

      console.log("_expectedLiquidityLU: ", _expectedLiquidityLU);
      console.log("expectedLiquidity: ", expectedLiquidity);
      console.log("totalAssets: ", totalAssets);
  }
```

2. Now, make the following changes to `PoolV3::repayCreditAccount`

```diff
  function repayCreditAccount(
      uint256 repaidAmount,
      uint256 profit,
      uint256 loss
  )
      external
      override
      creditManagerOnly // U:[LP-2C]
      whenNotPaused // U:[LP-2A]
      nonReentrant // U:[LP-2B]
  {
      uint128 repaidAmountU128 = repaidAmount.toUint128();

      DebtParams storage cmDebt = _creditManagerDebt[msg.sender];
      uint128 cmBorrowed = cmDebt.borrowed;
      if (cmBorrowed == 0) {
          revert CallerNotCreditManagerException(); // U:[LP-2C,14A]
      }

      if (profit > 0) {
          _mint(treasury, convertToShares(profit)); // U:[LP-14B]
      } else if (loss > 0) {
          address treasury_ = treasury;
          uint256 sharesInTreasury = balanceOf(treasury_);
          uint256 sharesToBurn = convertToShares(loss);
          if (sharesToBurn > sharesInTreasury) {
              unchecked {
                  emit IncurUncoveredLoss({
                      creditManager: msg.sender,
                      loss: convertToAssets(sharesToBurn - sharesInTreasury)
                  }); // U:[LP-14D]
              }
              sharesToBurn = sharesInTreasury;
          }
          _burn(treasury_, sharesToBurn); // U:[LP-14C,14D]
      }

      _updateBaseInterest({
-           expectedLiquidityDelta: -loss.toInt256(),
+           expectedLiquidityDelta: profit.toInt256() - loss.toInt256(),
          availableLiquidityDelta: 0,
          checkOptimalBorrowing: false
      }); // U:[LP-14B,14C,14D]

      _totalDebt.borrowed -= repaidAmountU128; // U:[LP-14B,14C,14D]
      cmDebt.borrowed = cmBorrowed - repaidAmountU128; // U:[LP-14B,14C,14D]

      emit Repay(msg.sender, repaidAmount, profit, loss); // U:[LP-14B,14C,14D]
  }
```

Then proceed to run the same test as step 1.

```text
Running 1 test for src/test/unit/Flashlender.t.sol:FlashlenderTest
[PASS] testIncorrectExpectedLiquidity() (gas: 158976)
Logs:
_expectedLiquidityLU:  1000000000000000000000000
expectedLiquidity:  1000000000000000000000000
totalAssets:  1000000000000000000000000

Test result: ok. 1 passed; 0 failed; 0 skipped; finished in 4.68ms

Ran 1 test suites: 1 tests passed, 0 failed, 0 skipped (1 total tests)
```

```text
Running 1 test for src/test/unit/Flashlender.t.sol:FlashlenderTest
[PASS] testIncorrectExpectedLiquidity() (gas: 159069)
Logs:
_expectedLiquidityLU:  1005000000000000000000000
expectedLiquidity:  1005000000000000000000000
totalAssets:  1005000000000000000000000

Test result: ok. 1 passed; 0 failed; 0 skipped; finished in 4.92ms

Ran 1 test suites: 1 tests passed, 0 failed, 0 skipped (1 total tests)
```

## Tools Used

Manual review, foundry.

## Recommended Mitigation Steps

The `Gearbox protocol` ensures that [profit is included](https://github.com/Gearbox-protocol/core-v3/blob/main/contracts/pool/PoolV3.sol#L503) when updating `expected liquidity`. Consider incorporating the same mechanism:

```diff
  _updateBaseInterest({
-       expectedLiquidityDelta: -loss.toInt256(),
+       expectedLiquidityDelta: profit.toInt256() - loss.toInt256(),
      availableLiquidityDelta: 0,
      checkOptimalBorrowing: false
  }); // U:[LP-14B,14C,14D]
```

[M-1] `AuraVault` reward calculation can be incorrect due to insufficient Chainlink `latestRoundData()` check

# Vulnerability details

## Impact

`AuraVault::claim` allows users to deposit `WETH` for `BAL` and `AURA` rewards. The function call calculates the amount of `WETH` to take from the user based off the amount of rewards they specified.

Chainlink's `latestRoundData()` is used to calculate the amount of `WETH` required for both `BAL` and `AURA` rewards specified by the caller.

However, `_getAuraSpot()` has no validation for the `latestRoundData()`, and `_chainlinkSpot()` only checks that the `amount returned > 0`.

This check is insufficient as the oracle may return stale or incorrect results [#1](https://docs.chain.link/data-feeds/historical-data), leading to an incorrect reward calculation, which can take far more or less `WETH` from the caller based off the rewards specified. The `maxAmountIn` slippage is not sufficient enough to protect against this.

Due to the fact that `latestRoundData()` is used twice (for `BAL` and `AURA`), this doubles the chance that stale or incorrect results will be returned, which will have the impact of loss of funds for either the protocol or the caller, and potential DoS due to insufficient funds. This warrants a `medium severity` vulnerability.

In addition, this is a [known issue](https://solodit.xyz/issues/m-04-chainlinks-latestrounddata-might-return-stale-or-incorrect-results-code4rena-predy-predy-git).

## Proof of Concept

To receive `BAL` and `AURA` rewards, users must call `AuraVault::claim` and specify the amount of rewards they would like to receive, where they must deposit `WETH` corresponding to the amount of rewards specified:

[AuraVault.sol#L280-L310](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/vendor/AuraVault.sol#L280-L310)
```javascript
function claim(uint256[] memory amounts, uint256 maxAmountIn) external returns (uint256 amountIn) {
    // Claim rewards from Aura reward pool
    IPool(rewardPool).getReward();

    // Compute assets amount to be sent to the Vault
    VaultConfig memory _config = vaultConfig;
@>      amountIn = _previewReward(amounts[0], amounts[1], _config);

    // Transfer assets to Vault
    require(amountIn <= maxAmountIn, "!Slippage");
    IERC20(asset()).safeTransferFrom(msg.sender, address(this), amountIn);

    // Compound assets into "asset" balance
    IERC20(asset()).safeApprove(rewardPool, amountIn);
    IPool(rewardPool).deposit(amountIn, address(this));

    // Distribute BAL rewards
    IERC20(BAL).safeTransfer(_config.lockerRewards, (amounts[0] * _config.lockerIncentive) / INCENTIVE_BASIS);
    IERC20(BAL).safeTransfer(msg.sender, amounts[0]);

    // Distribute AURA rewards
    if (block.timestamp <= INFLATION_PROTECTION_TIME) {
        IERC20(AURA).safeTransfer(_config.lockerRewards, (amounts[1] * _config.lockerIncentive) / INCENTIVE_BASIS);
        IERC20(AURA).safeTransfer(msg.sender, amounts[1]);
    } else {
        // after INFLATION_PROTECTION_TIME
        IERC20(AURA).safeTransfer(_config.lockerRewards, IERC20(AURA).balanceOf(address(this)));
    }

    emit Claimed(msg.sender, amounts[0], amounts[1], amountIn);
}
```

The amount of `WETH` calculated is based off the amount of rewards specified and a chainlink oracle for both `BAL` and `AURA` rewards.

[AuraVault.sol#L325-L333](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/vendor/AuraVault.sol#L325-L333)
```javascript
function _previewReward(
    uint256 balReward,
    uint256 auraReward,
    VaultConfig memory config
) private view returns (uint256 amount) {
@>      amount = (balReward * _chainlinkSpot()) / IOracle(feed).spot(asset());
@>      amount = amount + (auraReward * _getAuraSpot()) / IOracle(feed).spot(asset());
    amount = (amount * (INCENTIVE_BASIS - config.claimerIncentive)) / INCENTIVE_BASIS;
}
```

[AuraVault.sol#L365-L391](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/vendor/AuraVault.sol#L365-L391)
```javascript
function _chainlinkSpot() private view returns (uint256 price) {
    bool isValid;
    try AggregatorV3Interface(BAL_CHAINLINK_FEED).latestRoundData() returns (
        uint80 /*roundId*/,
        int256 answer,
        uint256 /*startedAt*/,
        uint256 /*updatedAt*/,
        uint80 /*answeredInRound*/
    ) {
        price = wdiv(uint256(answer), BAL_CHAINLINK_DECIMALS);
@>          isValid = (price > 0);
    } catch {}

    if (!isValid) revert AuraVault__chainlinkSpot_invalidPrice();
}

function _getAuraSpot() internal view returns (uint256 price) {
    uint256 ethPrice;
@>      (, int256 answer, , , ) = AggregatorV3Interface(ETH_CHAINLINK_FEED).latestRoundData();
    ethPrice = wdiv(uint256(answer), ETH_CHAINLINK_DECIMALS);

    IPriceOracle.OracleAverageQuery[] memory queries = new IPriceOracle.OracleAverageQuery[](1);
    queries[0] = IPriceOracle.OracleAverageQuery(IPriceOracle.Variable.PAIR_PRICE, 1800, 0);
    uint256[] memory results = IPriceOracle(auraPriceOracle).getTimeWeightedAverage(queries);

    price = wmul(results[0], ethPrice);
}
```

We can see two issues here. Firstly, the `_chainlinkSpot()` function only validates that the `price > 0`. Secondly, the `_getAuraSpot()` does not have *any* validation for the chainlink oracle price returned.

This means that the chainlink oracle may return stale or incorrect results, causing an incorrect reward calculation. As mentioned, this may allow cases such as allowing the caller to deposit less `WETH` for more rewards, or DoS due to insufficient funds.

## Tools Used

Manual review

## Recommended Mitigation Steps

Incorporate checks for stale data:

```javascript
+ uint256 private constant VALID_TIME_PERIOD = 5 * 60;

function _chainlinkSpot() private view returns (uint256 price) {
    bool isValid;
    try AggregatorV3Interface(BAL_CHAINLINK_FEED).latestRoundData() returns (
-           uint80 /*roundId*/,
+           uint80 quoteRoundID,
        int256 answer,
        uint256 /*startedAt*/,
-           uint256 /*updatedAt*/,
+           uint256 quoteTimestamp,
-           uint80 /*answeredInRound*/
+           uint80 quoteAnsweredInRound
    ) {
        price = wdiv(uint256(answer), BAL_CHAINLINK_DECIMALS);
        isValid = (price > 0);
        require(quoteAnsweredInRound >= quoteRoundID, "Stale price!");
        require(quoteTimestamp != 0, "Round not complete!");
        require(block.timestamp - quoteTimestamp <= VALID_TIME_PERIOD);
    } catch {}

    if (!isValid) revert AuraVault__chainlinkSpot_invalidPrice();
}

function _getAuraSpot() internal view returns (uint256 price) {
    uint256 ethPrice;
-       (, int256 answer, , , ) = AggregatorV3Interface(ETH_CHAINLINK_FEED).latestRoundData();
+       (uint80 quoteRoundID, int256 answer,, uint256 quoteTimestamp, uint80 quoteAnsweredInRound) = AggregatorV3Interface(ETH_CHAINLINK_FEED).latestRoundData();
+       require(quoteAnsweredInRound >= quoteRoundID, "Stale price!");
+       require(quoteTimestamp != 0, "Round not complete!");
+       require(block.timestamp - quoteTimestamp <= VALID_TIME_PERIOD);
+       require(answer > 0);
    ethPrice = wdiv(uint256(answer), ETH_CHAINLINK_DECIMALS);

    IPriceOracle.OracleAverageQuery[] memory queries = new IPriceOracle.OracleAverageQuery[](1);
    queries[0] = IPriceOracle.OracleAverageQuery(IPriceOracle.Variable.PAIR_PRICE, 1800, 0);
    uint256[] memory results = IPriceOracle(auraPriceOracle).getTimeWeightedAverage(queries);

    price = wmul(results[0], ethPrice);
}
```

# [M-2] `AuraVault` lacks slippage protection for deposit, mint, withdraw, redeem

# Vulnerability details

## Impact

`AuraVault::deposit` and `AuraVault::mint` allow users to deposit assets, which mints shares for them. The shares to mint are calculated by the following:

`assets.mulDiv(totalSupply() + 10 ** _decimalsOffset(), totalAssets() + 1, rounding);`

`AuraVault::withdraw` and `AuraVault::redeem` allow users to burn shares in return for assets. The number of assets are calculated by the following:

`shares.mulDiv(totalAssets() + 1, totalSupply() + 10 ** _decimalsOffset(), rounding);`

The `totalAssets()` and `totalSupply()` are not 1:1, largely due to the `AuraVault::claim` function, which allows users to deposit underlying for rewards instead of shares.

Therefore, if the values of `totalAssets()` and `totalSupply()` changes prior to function execution (i.e., while the call is in the mempool), this can cause a loss of funds for users.

## Proof of Concept

[AuraVault.sol#L199-L208](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/vendor/AuraVault.sol#L199-L208)
```javascript
function deposit(uint256 assets, address receiver) public virtual override(IERC4626, ERC4626) returns (uint256) {
    uint256 shares = previewDeposit(assets);
    _deposit(_msgSender(), receiver, assets, shares);

    // Deposit  in reward pool
    IERC20(asset()).safeApprove(rewardPool, assets);
    IPool(rewardPool).deposit(assets, address(this));

    return shares;
}
```

The shares to mint are calculated via a call to `ERC4626::previewDeposit` (inherited by the `AuraVault` contract), which calls the internal `_convertToShares`:

[AuraVault.sol#L182-L184](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/vendor/AuraVault.sol#L182-L184)
```javascript
function _convertToShares(uint256 assets, Math.Rounding rounding) internal view virtual override returns (uint256) {
    return assets.mulDiv(totalSupply() + 10 ** _decimalsOffset(), totalAssets() + 1, rounding);
}
```

We can see that this value relies on the current `totalSupply()` and `totalAssets()`, which can change prior to function execution:

[AuraVault.sol#L175-L177](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/vendor/AuraVault.sol#L175-L177)
```javascript
function totalAssets() public view virtual override(IERC4626, ERC4626) returns (uint256) {
    return IPool(rewardPool).balanceOf(address(this));
}
```

Users can alternatively call `AuraVault::claim`, to deposit underlying for rewards rather than shares:

[AuraVault.sol#L280-L310](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/vendor/AuraVault.sol#L280-L310)
```javascript
function claim(uint256[] memory amounts, uint256 maxAmountIn) external returns (uint256 amountIn) {
    // Claim rewards from Aura reward pool
    IPool(rewardPool).getReward();

    // Compute assets amount to be sent to the Vault
    VaultConfig memory _config = vaultConfig;
    amountIn = _previewReward(amounts[0], amounts[1], _config);

    // Transfer assets to Vault
    require(amountIn <= maxAmountIn, "!Slippage");
    IERC20(asset()).safeTransferFrom(msg.sender, address(this), amountIn);

    // Compound assets into "asset" balance
    IERC20(asset()).safeApprove(rewardPool, amountIn);
@>      IPool(rewardPool).deposit(amountIn, address(this));

    // Distribute BAL rewards
    IERC20(BAL).safeTransfer(_config.lockerRewards, (amounts[0] * _config.lockerIncentive) / INCENTIVE_BASIS);
    IERC20(BAL).safeTransfer(msg.sender, amounts[0]);

    // Distribute AURA rewards
    if (block.timestamp <= INFLATION_PROTECTION_TIME) {
        IERC20(AURA).safeTransfer(_config.lockerRewards, (amounts[1] * _config.lockerIncentive) / INCENTIVE_BASIS);
        IERC20(AURA).safeTransfer(msg.sender, amounts[1]);
    } else {
        // after INFLATION_PROTECTION_TIME
        IERC20(AURA).safeTransfer(_config.lockerRewards, IERC20(AURA).balanceOf(address(this)));
    }

    emit Claimed(msg.sender, amounts[0], amounts[1], amountIn);
}
```

This will increase `totalAssets()` but not `totalShares()`.

Consider the following scenario:

Alice calls `deposit` with `assets = 100e18 underlying token`. Assume `totalAssets() = 100e18` and `totalShares() = 50e18`.

Alice should receive (and expects to receive) `100e18 * (50e18 + 1) / (100e18 + 1) =  50e18 shares.`

However, Bob calls `AuraVault::claim`, depositing `100e18 underlying` but no shares are minted. Now, `totalAssets() = 200e18` and `totalShares() = 50e18`.

Alice's call is executed, and she receives `100e18 * (50e18 + 1) / (200e18 + 1) =  25e18 shares.`.

Alice suffers due to lack of slippage protection.

This exact concept applies to [mint](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/vendor/AuraVault.sol#L216), [withdraw](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/vendor/AuraVault.sol#L233), and [redeem](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/vendor/AuraVault.sol#L256) functions.

> The asset to share ratio will not be 1:1. This is largely due to the `AuraVault::claim` call which deposits underlying for 0 shares in return. In addition, user shares are rounded up when burned (in favor of protocol) during withdraw/> redeem calls, causing there to be less shares than assets.

## Tools Used

Manual review

## Recommended Mitigation Steps

It's important to note that adding an extra parameter to deposit, mint, withdraw, redeem functions will violate EIP-4626 standard. Therefore, the recommended solution is to create additional deposit,mint,withdraw,redeem functions that have slippage parameters, allowing users to opt-in slippage as they wish.

- deposit should allow users to specify minimum shares minted
- mint should allow users to specify maximum assets transferred
- withdraw should allow users to specify maximum shares burned
- redeem should allow users to specify minimum assets returned

# [M-3] `CDPVault::liquidatePositionBadDebt` incorrectly calculates the `debt loss`, causing incorrect accounting within `PoolV3` and more treasury shares to burn

# Vulnerability details

## Impact

A position in bad debt can be liquidated by anyone via `CDPVault::liquidatePositionBadDebt`, which sells the collateral to the liquidator at a discount.

The function call proceeds to count the `total debt - repay amount` as the loss, and calls `PoolV3::repayCreditAccount` with the loss as one of the parameters.

The problem is that `total debt - repay amount` doesn't truly represent the loss, as `total debt` includes the `accrued interest`. The `accrued interest` is the profit the protocol earns from the lending mechanism, if this can't be paid by the borrower or liquidator, this is *not* funds lost. It is rather potential profits that are lost.

Therefore, the loss is inflated, causing the protocol to burn more treasury shares that it needs to (possibly DoS if there is not enough), and heavily decreasing the `expectedLiquidity_` accounting within `PoolV3`, which is used for various calculations, such as the base interest rate. This will cause a loss of funds for the protocol and potential lenders.

## Proof of Concept

The following is executed in `CDPVault::liquidatePositionBadDebt`:

[CDPVault.sol#L606-L624](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/CDPVault.sol#L606-L624)
```javascript
repayAmount = wmul(takeCollateral, discountedPrice);
@>  uint256 loss = calcTotalDebt(debtData) - repayAmount;

// transfer the repay amount from the liquidator to the vault
poolUnderlying.safeTransferFrom(msg.sender, address(pool), repayAmount);

position.cumulativeQuotaInterest = 0;
position.cumulativeQuotaIndexLU = debtData.cumulativeQuotaIndexNow;
// update liquidated position
position = _modifyPosition(
    owner,
    position,
    0,
    debtData.cumulativeIndexNow,
    -toInt256(takeCollateral),
    totalDebt
);

@>  pool.repayCreditAccount(debtData.debt, 0, loss); // U:[CM-11]
```

Let's look at how `calcTotalDebt` calculates the total debt:

[CDPVault.sol#L733-L737](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/CDPVault.sol#L733-L737)
```javascript
/// @dev Computes total debt, given raw debt data
/// @param debtData See `DebtData` (must have debt data filled)
function calcTotalDebt(DebtData memory debtData) internal pure returns (uint256) {
    return debtData.debt + debtData.accruedInterest; //+ debtData.accruedFees;
}
```

Notice how it includes the `accruedInterest`. This is considered the profit from the debt position, as it's done on other instances such as `CDPVault::liquidatePosition`:

[CDPVault.sol#L548-L563](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/CDPVault.sol#L548-L563)
```javascript
@>          profit = debtData.accruedInterest;
        position.cumulativeQuotaInterest = 0;
    ...

    pool.repayCreditAccount(debtData.debt - newDebt, profit, 0); // U:[CM-11]
```

We can therefore conclude that `loss = calcTotalDebt(debtData) - repayAmount;` does not correctly reflect the true loss the position has gone under, and instead inflates the `loss`.

Consider the following example:

Bob borrows `10e18` WETH by depositing `20e18` collateral token. Interest accrues such that the debt is now `12e18 WETH`, and the position now has bad debt.

Alice liquidates the bad debt via a call to `liquidatePositionBadDebt` and buys the `20e18` collateral for a discount, at `8e18 WETH`.

The loss is calculated as `12e18 WETH - 8e18 WETH = 4e18 WETH`. However, we can clearly see the true loss is `10e18 WETH - 8e18 WETH = 2e18 WETH`. Since the loss includes debt accrued, it is inflated.

We can observe [here](https://github.com/code-423n4/2024-07-loopfi/blob/main/src/PoolV3.sol#L529) how the call to `PoolV3::repayCreditAccount` will now attempt to burn more shares due to an inflated loss, and lower the `expected liquidity` that will impact various features such as the `base interest rate`.

## Tools Used

Manual review

## Recommended Mitigation Steps

Exclude the `accruedInterest` when calculating the `loss`:

```diff
function liquidatePositionBadDebt(address owner, uint256 repayAmount) external whenNotPaused {
    // validate params
    if (owner == address(0) || repayAmount == 0) revert CDPVault__liquidatePosition_invalidParameters();

    // load configs
    VaultConfig memory config = vaultConfig;
    LiquidationConfig memory liqConfig_ = liquidationConfig;

    // load liquidated position
    Position memory position = positions[owner];
    DebtData memory debtData = _calcDebt(position);
    uint256 spotPrice_ = spotPrice();
    if (spotPrice_ == 0) revert CDPVault__liquidatePosition_invalidSpotPrice();
    // verify that the position is indeed unsafe
    if (_isCollateralized(calcTotalDebt(debtData), wmul(position.collateral, spotPrice_), config.liquidationRatio))
        revert CDPVault__liquidatePosition_notUnsafe();

    // load price and calculate discounted price
    uint256 discountedPrice = wmul(spotPrice_, liqConfig_.liquidationDiscount);
    // Enusure that the debt is greater than the collateral at discounted price
    if (calcTotalDebt(debtData) <= wmul(position.collateral, discountedPrice)) revert CDPVault__noBadDebt();
    // compute collateral to take, debt to repay
    uint256 takeCollateral = wdiv(repayAmount, discountedPrice);
    if (takeCollateral < position.collateral) revert CDPVault__repayAmountNotEnough();

    // account for bad debt
    takeCollateral = position.collateral;
    repayAmount = wmul(takeCollateral, discountedPrice);
-       uint256 loss = calcTotalDebt(debtData) - repayAmount;
+       uint256 loss = calcTotalDebt(debtData) - repayAmount - debtData.accruedInterest;

    // transfer the repay amount from the liquidator to the vault
    poolUnderlying.safeTransferFrom(msg.sender, address(pool), repayAmount);

    position.cumulativeQuotaInterest = 0;
    position.cumulativeQuotaIndexLU = debtData.cumulativeQuotaIndexNow;
    // update liquidated position
    position = _modifyPosition(
        owner,
        position,
        0,
        debtData.cumulativeIndexNow,
        -toInt256(takeCollateral),
        totalDebt
    );

    pool.repayCreditAccount(debtData.debt, 0, loss); // U:[CM-11]
    // transfer the collateral amount from the vault to the liquidator
    token.safeTransfer(msg.sender, takeCollateral);

    int256 quotaRevenueChange = _calcQuotaRevenueChange(-int(debtData.debt));
    if (quotaRevenueChange != 0) {
        IPoolV3(pool).updateQuotaRevenue(quotaRevenueChange); // U:[PQK-15]
    }
}
```
